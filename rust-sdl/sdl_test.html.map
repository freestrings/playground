{"version":3,"file":"sdl_test.html","sources":["/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/surface.rs","/checkout/src/liballoc/rc.rs","/checkout/src/libcollections/slice.rs","/checkout/src/libcore/cell.rs","/checkout/src/liballoc/boxed.rs","/checkout/src/libcore/ptr.rs","/checkout/src/libcore/nonzero.rs","/checkout/src/libcore/any.rs","/checkout/src/libcore/option.rs","/checkout/src/libcore/macros.rs","/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/render.rs","/work/<panic macros>","/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/lib.rs","/checkout/src/libstd/sys_common/thread_local.rs","/checkout/src/libstd/ffi/c_str.rs","/checkout/src/libstd/sys/unix/thread_local.rs","/checkout/src/libstd/path.rs","/checkout/src/libstd/thread/local.rs","/checkout/src/libstd/panicking.rs","/checkout/src/liballoc/raw_vec.rs","/checkout/src/libcore/mem.rs","/checkout/src/libcore/result.rs","/checkout/src/libcore/fmt/mod.rs","/checkout/src/libcore/num/mod.rs","/checkout/src/libcore/sync/atomic.rs","/checkout/src/libcore/slice/mod.rs","/checkout/src/libcore/lib.rs","/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/sdl.rs","/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/rect.rs","/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/rwops.rs","/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/pixels.rs","/work/<try macros>","/checkout/src/libcore/convert.rs","/work/<assert macros>","/checkout/src/liballoc/heap.rs","/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/video.rs","/checkout/src/libcollections/string.rs","/checkout/src/libcore/str/mod.rs","/checkout/src/libcollections/vec.rs","src/main.rs","<__thread_local_inner macros>","/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/common.rs","/root/.cargo/registry/src/github.com-1ecc6299db9ec823/sdl2-0.30.0/src/sdl2/timer.rs","/checkout/src/libstd/io/error.rs","/checkout/src/libstd/sys/unix/rwlock.rs","/checkout/src/libstd/sys_common/util.rs","/checkout/src/libstd/env.rs","/checkout/src/libstd/sys_common/backtrace.rs","/checkout/src/libstd/sys_common/thread_info.rs","/checkout/src/liballoc/arc.rs","/checkout/src/libstd/sys/unix/mod.rs","/checkout/src/libstd/sys/unix/os.rs","/checkout/src/libcore/ops.rs","/checkout/src/libstd/sys/unix/mutex.rs","/checkout/obj/<assert macros>","/checkout/obj/<panic macros>","/checkout/src/libcore/iter/mod.rs","/checkout/src/libstd/sys/unix/backtrace/printing/dladdr.rs","/checkout/src/libcore/str/pattern.rs","/checkout/src/libstd_unicode/char.rs","/checkout/src/libcore/iter/iterator.rs","/checkout/src/libcore/char.rs","/checkout/src/libcore/cmp.rs","/checkout/src/libstd/sys/unix/fd.rs","/checkout/src/libstd/sys/unix/stdio.rs","/checkout/src/libstd/io/impls.rs","/checkout/src/libstd/io/mod.rs","/checkout/src/libstd/error.rs","/checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs","/checkout/src/libstd/thread/mod.rs","/checkout/src/libstd/sys/unix/memchr.rs","/checkout/src/libstd/sys_common/mutex.rs","/checkout/src/libstd/sync/mutex.rs","/checkout/src/libstd/sys_common/condvar.rs","/checkout/src/libstd/sys/unix/condvar.rs","/checkout/src/libstd/sync/condvar.rs","/checkout/src/libcore/fmt/builders.rs","/checkout/src/libstd/sys/unix/os_str.rs","/checkout/src/libcollections/borrow.rs","/checkout/src/libstd/sys_common/poison.rs","/checkout/src/libstd/ffi/os_str.rs","/checkout/src/libstd/sync/once.rs","/checkout/src/libstd/sys/unix/args.rs","/checkout/src/libstd/sys_common/at_exit_imp.rs","/checkout/src/libstd/rt.rs","/checkout/src/libcore/iter/range.rs","/checkout/src/libpanic_unwind/emcc.rs","/checkout/src/libpanic_unwind/lib.rs","/checkout/src/libunwind/libunwind.rs","/checkout/src/libcollections/str.rs","/checkout/src/liballoc/oom.rs","/checkout/src/libstd_unicode/tables.rs","/checkout/src/liballoc_system/lib.rs","/checkout/src/libcore/panicking.rs","/checkout/src/libcore/fmt/num.rs","/checkout/src/libcore/char_private.rs","/checkout/src/libcore/clone.rs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoFA;AAAA;AACA;;AC0kBA;AAAA;AACA;;AA6gBA;AAAA;AAEA;AAAA;AA/gBA;AD3kBA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AEkWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AD9IA;AAAA;AAAA;AAOA;AAAA;;AACA;;;;;;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AACA;AAAA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AALA;AAYA;AAAA;;;;;;;;;;;;;;;;AAPA;AAAA;;AAOA;AAAA;;AAdA;AAAA;AAAA;;;;AAcA;AAAA;AAdA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAOA;AAAA;;AACA;;;;;;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AALA;AAYA;AAAA;;;;;;;;;;;;;;;;AAPA;AAAA;;AAOA;AAAA;;AAdA;AAAA;AAAA;;;;AAcA;AAAA;AAdA;AAAA;AAAA;;;;;;;;;;;AE5FA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;AA4FA;AAAA;AAEA;AAAA;AAAA;AAAA;AADA;AAGA;AAAA;;;;;;;;;;AAuDA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AAwCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;AAAA;AAAA;;AAAA;;;;AACA;;;;;;;;AAAA;AAAA;;AAFA;AAAA;AAAA;;;;AAEA;AAFA;AAAA;AAAA;;;;;;;;;;;AC3IA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAwBA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AC40BA;AAAA;AACA;;ACvkCA;AAAA;AACA;AAAA;AACA;ADqkCA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;AAFA;AAAA;AACA;;ACvkCA;AAAA;AACA;AAAA;AACA;ADqkCA;AAAA;AAAA;AACA;AAAA;;;;;;;;;AAqBA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AApBA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAFA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAFA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAFA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAFA;AACA;AAAA;AAAA;AACA;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AA7HA;AACA;AAAA;AAAA;AACA;;;;;;;;;;AEt5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AJwiBA;AAAA;AACA;AAAA;AAAA;A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A;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;AA4iBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAlEA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;AAFA;AAAA;AACA;AAAA;AAAA;AACA;;;;;AA5dA;;;;;AAAA;;;;;AAcA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;;;;;;AFw4BA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;;AAFA;AAEA;AAAA;;;;;;;;;;;;;;;;AqB7nBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AA+pBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AA4YA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AACA;AAAA;AAAA;AAMA;AAAA;;;;Afl5CA;AAAA;;;;Ae24CA;AAAA;AAAA;AAOA;AAAA;;;;Afl5CA;AAAA;;;;Ae64CA;AAAA;AAAA;AAKA;AAAA;;;;Afl5CA;AAAA;;;;;;;;;;;;;;;;;;Aeq5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;;;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;Af95CA;;;;;;;Ae85CA;AAAA;;AATA;AAAA;AAAA;;;;AASA;AATA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AC08BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AJziDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AK11BA;AAAA;AAAA;AAAA;AAAA;AL01BA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AZ9zBA;;;;;AAAA;;;;;;;;;;AY+zBA;AAFA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AK11BA;AAAA;AAAA;AAAA;AAAA;AL01BA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AZ9zBA;;;;;AAAA;;;;;;;;;;AY+zBA;AAFA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AK11BA;AAAA;AAAA;AAAA;AAAA;AL01BA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AZ9zBA;;;;;AAAA;;;;;;;;;;AY+zBA;AAFA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AK11BA;AAAA;AAAA;AAAA;AAAA;AL01BA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AZ9zBA;;;;;AAAA;;;;;;;;;;AY+zBA;AAFA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AK11BA;AAAA;AAAA;AAAA;AAAA;AL01BA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AZ9zBA;;;;;AAAA;;;;;;;;;;AY6zBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AK11BA;AAAA;AAAA;AAAA;AAAA;AL01BA;;AZ9zBA;;;;AAAA;AAAA;AAAA;AY8zBA;;AZ9zBA;;;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AAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;AR+pCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;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;AH7OA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJrFA;AAAA;AErKA;AACA;AAAA;AAAA;AAAA;AAAA;;AOuQA;AAAA;APvQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AO2SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AP3SA;AAAA;;AACA;AFoKA;;AAGA;AEzKA;AACA;AAAA;AAAA;AAAA;AAAA;;AOuQA;AAAA;APvQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AO2SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AP3SA;AAAA;;AACA;AAgBA;AF2JA;;AAAA;AAAA;;;;;;;AW0xCA;;;;AXnxCA;;AElKA;;AFkKA;;;;;;;;;;AI2EA;AAAA;AAAA;AGuOA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;Af/bA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;;;;AAAA;A6ByGA;AAAA;AAGA;;;;AAHA;AACA;AAvCA;;;;;A7BnEA;A6ByGA;AAAA;AAGA;;;;;AAHA;AACA;AAvCA;;;;;A1BuHA;AAAA;;ACjOA;;;AQgRA;;;;;;;;;;;;AIqjBA;AAAA;AAAA;AACA;AAAA;AC/jBA;AAAA;AD+jBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC3hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AbnSA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AS6TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AIzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AJyBA;AAAA;AAAA;Ab7RA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AasSA;AAAA;AAAA;AAAA;;AMynCA;;;ANnnCA;;AIxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AJqCA;AbzS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AAAA;;;;;;;AYlKA;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYlKA;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYlKA;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYlKA;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYlKA;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYlKA;;;;;;AZ6JA;;AAKA;AAAA;;;;;;AsBloEA;AAAA;AKgjFA;AAIA;;;;;A/C78EA;;AgCy3DA;AAAA;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;A/C78EA;;AgCy3DA;AAAA;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;A/C78EA;;AgCy3DA;AAAA;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;A/C78EA;;AgCy3DA;AAAA;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;A/C78EA;;AgCy3DA;AAAA;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;A/C78EA;;AgCy3DA;AAAA;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;A/C78EA;;AgCy3DA;AAAA;;;;;;AAhiBA;;;;;;;AhCz1CA;AgCy3DA;AAAA;;;;;;;;;AZ6JA;;AAKA;AAAA;;;;;AsBloEA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AA4hBA;;;;AAEA;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYpKA;;;;;;AAEA;;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYpKA;;;;;;AAEA;;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYpKA;;;;;;AAEA;;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYpKA;;;;;;AAEA;;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYpKA;;;;;;AAEA;;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYpKA;;;;;;AAEA;;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYpKA;;;;;;AAEA;;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYpKA;;;;;;AAEA;;;;;;;AZ6JA;;;AAKA;AAAA;;;;;;;AYpKA;;;;;;AAEA;;;;;;;AZ6JA;;AAKA;AAAA;;;;;AsBloEA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;AUh8CA;AAAA;AKgjFA;AAIA;;;;;;A/C78EA;;;AgCu3DA;;;;;AhCv3DA;AgCy3DA;AAAA;;;;;;;;AAhiBA;;;;;;;;;;;AAgiBA;AAAA;;;;;AZ9tCA;ApB3pBA;AgCJA;;;AAAA;;;AA3BA;AAAA;AZ0rBA;;;;ApB3pBA;AgCjBA;AADA;;;AATA;AAAA;AAAA;AAiCA;;;;;AZqpBA;;;;ApB3pBA;AgCjBA;AADA;;;AATA;AAAA;AAAA;AAsCA;AAAA;AACA;;;;;AZ+oBA;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sE+ZA;AD/UA;ArEhFA;A6BmEA;A7BnEA;;;;;;;;;;;;;AiDvDA;;ACDA;AAAA;;ApCiGA;;;;Ae1CA;A7B8eA;;Ac1bA;AAAA;;;;;AAKA;AmBkPA;AAAA;AAAA;AAAA;AAAA;;AAm/CA;;;;;;AnB1yCA;AAAA;;;;;AAvZA;AezBA;;;;AI4gCA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;AvB5eA;AoEnJA;AjEuhBA;;ASjUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AALA;;AwDzMA;AAAA;AAAA;AxD6MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AALA;;;;;;;;;;;;;;;AqDnBA;;;;;A/D8BA;A8BnLA;A7B8eA;;;A6B7YA;;;;A9BmFA;A8BpLA;A7B8eA;;;A6B7YA;;;;A9BmFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AuCMA;AAAA;AAAA;AAAA;AAAA;AxB0TA;AAAA;AAAA;;ALjCA;;AKtXA;AAAA;AezBA;ApB+YA;;;;;AKiCA;AAAA;AAAA;;;;;AAvZA;AAAA;AezBA;;;;;;;;;AI6UA;AAAA;AnBzSA;AAAA;AIkmDA;AJj2CA;;AmByCA;;Af09CA;AAAA;;AfznDA;;;AWuDA;A2CicA;AAhGA;ARjsBA;;ACDA;AAAA;;ApCwaA;;AejXA;;;Af6FA;Ae3DA;;;A7B4cA;;AclHA;AAAA;;AAGA;AACA;AmBkBA;;;;;;;;;;AhBs/BA;AAAA;AAAA;AuDl0CA;ACsKA;AAAA;;AxD4pCA;AAAA;AgBqMA;;;;;AhB3LA;;;;;;AH95BA;AdnfA;;;;;A6BmEA;;;;AfgbA;AdnfA;;AiBu4CA;;AYp0CA;AZo0CA;;;;;;;;ALhjCA;AO8gCA;AXzwCA;;;AAAA;;;;;;AqBzBA;;;;;;;;;AnBpGA;AmBoGA;AVkyCA;AXzwCA;;;AE7HA;AE4XA;;AJ/PA;;AE7HA;AE4XA;;;;;;AEwJA;AAAA;AAAA;;AdnfA;;Ac4FA;AezBA;A7BnEA;;;;;;AEuDA;;;;;;AFvDA;;;;;;;;AiBuIA;AgBspDA;AA9sBA;AAAA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;AH7cA;;;;;;;;;;;AAGA;AuC+MA;AAIA;;AzB0jBA;AEXA;AAAA;AnBtyBA;AAAA;AmBsyBA;;AACA;;;;;;AnBlzBA;AdidA;AAzXA;AiC+tBA;AAAA;AAAA;AhBvwBA;;AuCgNA;;;;AAwBA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AxDoLA;AwDpLA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AxD+KA;AwD/KA;AAAA;AACA;AAAA;AAAA;AxD8KA;AwD9KA;;;;;;;;;AxD8KA;;;AiCgvCA;AA9sBA;AAAA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;AHzcA;;;;;;;;;;AAGA;AAIA;AAAA;AAAA;AAHA;;;;;;;;;;;;A6B3GA;AAAA;;AACA;AAAA;;ArC6gBA;AWoOA;;AACA;AAAA;;A0B9uBA;A9BwnBA;AAAA;AAAA;AAAA;AAAA;AAEA;;A8B1nBA;AAEA;;A9BynBA;AAAA;AAAA;AAAA;;;;;;;;;AFzkBA;AmBg/CA;AAAA;AFgEA;AACA;;;;;;;;;;;Af/2BA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AC/jBA;AAAA;AD+jBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC3hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AbnSA;;;;;;;AJ+BA;;;;;;AEuDA;;;;;;;;;;;;;AU2EA;AAsIA;;ATtBA;;;AwChRA;AxC+QA;;AACA;;;A6DibA;AhEoaA;AgEnaA;AGlgBA;AnB3JA;;ApCmMA;;;;;;;ATuCA;AAAA;;;AACA;;;;;ASpCA;AAAA;;AGiPA;;;;;;;;AAAA;AF9CA;Af2qBA;AqBySA;AAxmCA;AHqaA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AgDAA;AAAA;;;;;AhEkaA;AmEvsBA;AGLA;AxEisBA;AqBmWA;;AmD5hCA;AAJA;;;;;AAvOA;AAAA;ADpJA;AlDi2CA;AAxmCA;;;;;;;;;AmD0IA;;;;;;;A1D7LA;;;;;;ATuCA;;;AACA;;;;ASpCA;AAAA;;AGiPA;;AAAA;;;;;AF9CA;;AMw8BA;;;;AgDx+BA;AnBrWA;;;;;AhCypBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AgDGA;;;;ApD9dA;;;;;;;ATuCA;;;AACA;;;;;ASpCA;AAAA;;AGiPA;;AAAA;;;;;AF9CA;;AMw8BA;;;;AgDx+BA;AnBrWA;AhD2jCA;AmBoUA;AAAA;AAAA;AyBzrBA;;AoBzCA;;ApB4EA;AoB5EA;;;;;;;;;;;;;AhE8ZA;AmBoUA;AAAA;AAAA;AyBzrBA;;;;;AAmCA;;;;;;;;;;;;;;A5ByCA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AC/jBA;AAAA;AD+jBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC3hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AbnSA;;;;A+D+YA;AO9XA;AAAA;AAAA;;;A9DwNA;ATuCA;;AACA;;;ASpCA;AAAA;;AGiPA;;AAAA;;;;;AF9CA;;Af2qBA;AqB6RA;;;;AgDx+BA;AAAA;AnBrWA;;;;;;;;;A0B+CA;AACA;;;;;;;;;A1E2gCA;AgE1MA;AG3tBA;AnB3JA;ApCmMA;ATuCA;AAAA;;AACA;;;ASpCA;AAAA;;AGiPA;;;;;;;;AAAA;AF9CA;Af2qBA;AqBySA;AAxmCA;;AHqaA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AlBuZA;AkE9LA;AAAA;;AACA;AMhjBA;AAAA;ADvVA;;;AFyXA;AnBrWA;AgBs3BA;;ApDxrBA;ATuCA;;AACA;;;ASpCA;AAAA;;AGiPA;;AAAA;AoD9EA;AnBrWA;AgBs3BA;;;;AnDjfA;;AsDhCA;AnBrWA;AgBs3BA;;A7CudA;AgDx+BA;AnBrWA;AgBs3BA;;;;;;;;A/BlfA;AAAA;AnBzSA;AAAA;AIkmDA;AJj2CA;;AmByCA;;Af09CA;AAAA;;AfznDA;;;AWuDA;A2CicA;AAhGA;AvCmxCA;AAAA;;Af3qDA;;;A8CzSA;;ACDA;AAAA;;ApCwaA;;AejXA;;;Af6FA;AAwRA;AenVA;;;A7B4cA;;AclHA;AAAA;;AAGA;AACA;AmBkBA;;;;;;;;;;;AxBxOA;AAAA;AAAA;AAAA;AAAA;AwDnNA;AjEuhBA;;ASjUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAEA;;AwDhNA;AAAA;AAAA;AxD6MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAEA;;;;;;;;AAgHA;AAAA;AAAA;AAgDA;AAAA;AAAA;AAAA;;;;;;;AAqOA;AAEA;AACA;AAAA;AAAA;AAAA;;;;;;;AA4FA;;;;;;;;AAiBA;AWoHA;;AACA;AAAA;;AXlFA;AACA;;;;;;;;;AkE1DA;AAAA;AAAA;AAAA;;;;;;;;;;AH5kBA;AxDmNA;AAEA;;AAFA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;ALqwCA;;AKpwCA;ALowCA;;;;;;;;;AAsuBA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AQ35BA;;;;;;;;;;;;;;;;;;;;;;;;AyDpmCA;AAAA;;;;;AhEhIA;AAsIA;;;;;A+BtSA;AxC+QA;;;;;AyEkBA;AAAA;AAAA;;;AAQA;AAAA;;;;;AACA;AAAA;AAAA;AzDmpCA;;;;;;;;;;AnB/5CA;AAAA;;AmB24CA;AAAA;AAAA;AyBzrBA;;AAmCA;;;;;;;AzBinBA;AAzmCA;;;;;AyD4BA;;;;;;;;AzD6kCA;AnBt2CA;AAAA;;AmB24CA;AAAA;AAAA;AyBzrBA;;AAmCA;;;;;;;AzB0qBA;;;;;;;;;;AyDjsCA;AAAA;;;AAmEA;;;AA9CA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAAA;;;;;;A5EvPA;;;;;A4EwPA;A5ExPA;A4EiSA;;;;AA/BA;AAAA;;;AzEhBA;;;;;;AHlPA;AAAA;;;;;;AmB24CA;AAAA;AAAA;AyBzrBA;;;;;;AAmCA;;;;;;;;;;;;;;;;;;;AgCtcA;AAAA;;;AAAA;AzDqkCA;AAAA;AyDhkCA;AAAA;AAAA;AAAA;AAAA;;A3DpFA;AAAA;A2DoFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A3DhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A2DgDA;AAAA;;AAOA;A5EkLA;;A4EzKA;;AATA;;;AAEA;AAAA;A7DiIA;AACA;AZ7KA;;;;;AyE4CA;A9E8vBA;AqB8RA;;AyD1hCA;;;;;;;A5EuwBA;AmBoUA;AAAA;AAAA;AyBzrBA;;AAmCA;;A5CxQA;;;;;;;;;A4EzKA;;;AxE3WA;;;;;;AJ8mCA;AmBoUA;AAAA;AAAA;AyBzrBA;;;;;AAmCA;;;;;;;;;A5CrvBA;;;;;;;;;;;;A4EuKA;A7DuRA;AACA;AZ7KA;;ACzTA;;;A4C8CA;AhDPA;AAAA;;Ac4FA;AmB2/CA;AAAA;AjCvlDA;AAAA;;;;AAAA;AcmfA;AAAA;AAAA;;AAvZA;AezBA;;A7BnEA;;;;;;;;AcmfA;AAAA;AAAA;;AAGA;AA1ZA;AezBA;;A7BnEA;A6BmEA;;AgDrCA;A7BlBA;;;;;AS0tBA;AV1cA;;;;;ACrRA;A8BjBA;AACA;AAAA;AAAA;A9BqBA;A8BjBA;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;A9E6iBA;;;AiC6lDA;;;;AjC9vDA;AApSA;A8ExGA;;;;;A9EwGA;AAAA;A8ExGA;A/EslBA;AAAA;;AAAA;;;;;;;;;;;;;AkCojDA;;;;AjC9vDA;AApSA;AAAA;AAAA;AiCwnEA;AAAA;;;;AjChuEA;AAAA;;AAAA;;;;;;;AAAA;A6ByGA;AAAA;AAGA;;AAHA;AACA;AAvCA;;AIukEA;;;;;;;;;;AnBvpDA;;AAGA;AenbA;;AAAA;;;;AiDxEA;AAAA;;;;;A7C+oEA;;;;;AjC9vDA;AApSA;AAAA;AAAA;AiCwnEA;AAAA;;;;AjChuEA;AAAA;;AAAA;;;;;;AAAA;A6ByGA;AAAA;AAGA;;AAHA;AACA;AAvCA;;AIukEA;;;;;;;;;AjC1oEA;A6ByGA;AAAA;AAGA;;;;;AAHA;AACA;AAvCA;;;;;AfgbA;;;AehbA;;;;AfmbA;AenbA;;AAAA;;;;;;;A7BnEA;A6ByGA;AAAA;AAGA;;AAHA;AACA;AAvCA;;;AAAA;;;;;A+CoGA;;;;;;;;;;;A7Bw5EA;AAAA;;;;;;;;;;;;;;;;;;;;AJzkFA;AAAA;;A/BoNA;;;;;ATuCA;;;AACA;;;;ASpCA;AAAA;;;AGgPA;AACA;AAAA;AAAA;AAAA;AAAA;Af/bA;AAAA;;AAAA;AAAA;AAAA;;AmB24CA;AAAA;AAAA;AyBzrBA;;;AAmCA;;;;;;;;;AzC3jBA;AAAA;;;ACjOA;;;;;;;;;;;;AN+LA;AAsnBA;;;AkBjFA;;;;AbvjBA;AAAA;AAqBA;;;AwCpKA;;;;AACA;A/B+MA;AAAA;AAAA;AAGA;;AAAA;;;;;;;ATuCA;;;AACA;;;;;ASrCA;AACA;AAAA;;;AGgPA;AACA;AAAA;AAAA;AAAA;AAAA;Af/bA;AAAA;;;;AAAA;AAAA;AAAA;;;;AmB24CA;AAAA;AAAA;AyBzrBA;;;AAmCA;;;;;;;;;;;;;AzC3jBA;AAAA;;;ACjOA;;;;;;;;;;;AJuCA;AAukCA;AmBoUA;AAAA;AAAA;AyBzrBA;;;;;AAmCA;;;;;;;;AD5vBA;AACA;AAAA;AAFA;AAAA;AAAA;A7CgKA;AAkxBA;AAAA;;;AkB7OA;;;;AhB7rBA;;;;;AmB24CA;AAAA;AAAA;AyBzrBA;;;;;A5CltBA;;A4CqvBA;;;;;;;;;;;;A7BtTA;AjB6nBA;AE5jCA;AAAA;AAAA;;A2CRA;A5BucA;A4BncA;;AxB+4CA;AAAA;AAAA;AyBzrBA;;AD1tBA;A5BucA;A4BncA;;;ACyvBA;;;;;;AD7vBA;A5BucA;;;;A4BvcA;A5BucA;A4BncA;;;;;;;AxB+4CA;AAAA;AAAA;AyBzrBA;;AAmCA;;;;;;;;;;;;;A5CkVA;AmBoUA;AAAA;AAAA;AyBzrBA;;;;;;AAmCA;;;;;;;;AzBgnBA;AXzwCA;;AAAA;;;;;AEvHA;AVwgBA;;AYlLA;AAGA;AAHA;;AAxLA;;AiBpIA;A7B8eA;;A6B7YA;AAAA;;AjBmOA;AAAA;AAAA;AOkiCA;AXzwCA;;AAAA;;;;;AE7HA;;AEoKA;;;;;;;;;;;;ACqRA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkEvbA;AlC2CA;AkCxBA;AAAA;AACA;AAAA;A9C8QA;AAAA;AAAA;AAAA;AAAA;A+C/LA;AAAA;;A/CupDA;;;;;;;;;;;AnBloDA;AmB2/CA;;;AjC1iCA;;;;;A+CjRA;A/CgHA;A6E1XA;ApEiiBA;AWoOA;;;;;A6B90BA;;;;;AnCgGA;;;;Ae1CA;A7B8eA;;;;;;;;AcrbA;AmBkPA;AAAA;AAAA;;AAm/CA;;;;;;;AA9sBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;AvB5eA;AoCynDA;;;;;AjC9iDA;AAAA;AAAA;AAyXA;AiC8vBA;AwBrkBA;;;;;;;;;;ArCkDA;;;;;;A8Bh1BA;;;;;;ApC2GA;;;;;;;AAgcA;AAAA;;;;AAvZA;AezBA;;;;;;;;;AI+uCA;;;;;;;AAAA;AAgaA;Ae3sDA;A7C+HA;AAqBA;;;A0EpIA;;;;A7EvBA;AAAA;;;;AAAA;AcmfA;AAAA;AAAA;;AAvZA;AezBA;;A7BnEA;;;;;;;;AcmfA;;;;;AAGA;AenbA;;;;AApEA;A7B8eA;;A6B7YA;AAAA;;AgDxEA;AAAA;AAAA;AAAA;AAAA;A7ExBA;AAAA;;Ac4FA;AmB2/CA;AAAA;AjCvlDA;AAAA;;;;AAAA;AcmfA;AAAA;AAAA;;AAvZA;AezBA;;A7BnEA;;;;;;;;AcmfA;AAAA;AAAA;;AAGA;AA1ZA;AezBA;;A7BnEA;A6BmEA;;AgD3CA;A7BZA;AnCmWA;AACA;AACA;AAIA;AAKA;;;;ADhLA;ATuCA;;AACA;;;ASpCA;AAAA;;AGiPA;;;;;;AHjPA;;;AGiPA;AF9DA;AACA;;;AMo+BA;AyDpsCA;;;AAIA;AACA;;AAAA;;;;;;;;A5EvKA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;A6ByGA;AAAA;AAGA;;;;;AAHA;AACA;AAvCA;;;;A7BnEA;A6ByGA;AAAA;AAGA;;;;;AAHA;AACA;AAvCA;;;;;;AbsLA;AhBzPA;;A+EQA;AAKA;;A/EbA;AAAA;;AAAA;;;;;;AAAA;A6ByGA;AAAA;AAGA;;;;;AAHA;AACA;AAvCA;;;;A7BnEA;A6ByGA;AAAA;AAGA;;AkDpGA;AAKA;;AlD4FA;AACA;AAvCA;AkD3DA;AAKA;;;;A/EbA;AAAA;;;;AAAA;AcmfA;AAAA;AAAA;;AAvZA;AezBA;;A7BnEA;;;;;;;;AcmfA;AAAA;;;;;AAGA;AenbA;;;;;;;;AgBzCA;AAGA;AAAA;;;;;;A7C2EA;A+ExGA;AAAA;AlE4YA;;;;;;AkCmrEA;ALl/EA;;;;;;;;;;AuC7EA;AACA;;;;;;;;;;ACqCA;;;;;AAQA;;;;AlF+bA;;AiFxgBA;AAAA;;AjFmIA;AAAA;AAAA;AiFjIA;ACmEA;AACA;;AAGA;;;;;;;;ADnEA;AAEA;AACA;;ACyEA;AADA;AlF8HA;AAAA;AAAA;AiFjMA;AAEA;;;AAVA;AjFqBA;;AAAA;;;;;;AAAA;A6ByGA;AAAA;AAGA;;;;;AAHA;AACA;AAvCA;;;;A7BnEA;A6ByGA;AAAA;AAGA;;AqDnDA;;ArDgDA;AACA;AAvCA;AqDVA;;;;;;;;;;;;;;;;;;;;;AChGA;AAAA;AAAA;;;;AlEk0CA;AkEl0CA;;;;;AlEk0CA;AkEl0CA;;;;;AlEk0CA;AkEl0CA;;;;;AlEk0CA;AkEl0CA;;;;;AlEk0CA;AkEl0CA;;;;;AlEk0CA;AkEl0CA;;;;;AlEk0CA;AkEl0CA;;;;;AlEk0CA;AkEl0CA;;;;;AlEk0CA;AkEl0CA;;;;;AlEk0CA;AkEl0CA;;;;;AAAA;;;;;;;;ArE8IA;AAAA;AIkmDA;AJj2CA;;AAyBA;;AI0+CA;AAAA;;AfznDA;;;AWuDA;A2CicA;AAhGA;ARjsBA;;ACDA;AAAA;;ApCwaA;;AejXA;;;Af6FA;Ae3DA;;;A7B4cA;;AclHA;AAAA;;AAGA;AACA;AAEA;;;;;;;;;;;;AmCxbA;;ACDA;AAAA;;ApCiGA;;;;Ae1CA;A7B8eA;;Ac1bA;AAAA;;;;;AAKA;AmBkPA;AAAA;AAAA;AAAA;AAAA;;AAsGA;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;AvB5eA;AkC6lBA;AqDlkBA;;;;AtE+WA;AAAA;;;;;AAvZA;AezBA;;;;;;;;;;;;;;;;;;;;;;;;;;;AE4ZA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwGA;;AAvGA;AAAA;AAAA;AAAA;AkBxhBA;;ACDA;AAAA;;ApCiGA;;;;Ae1CA;A7B8eA;;Ac1bA;AAAA;;;;;AAKA;AiByRA;AAAA;AAAA;AAAA;AAAA;AA+JA;;;;;;AXuSA;;;AACA;;;;;AaxYA;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;;;;;;;AW5FA;;;;;A/B7GA;A+B4FA;AAoBA;AAYA;;;;;ACw4BA;AAAA;AAAA;;;ADr6BA;;A/B/FA;A+B4FA;AAuCA;AAAA;;AAIA;;;;;AAHA;;AXqQA;;;;;AAEA;;;;;AAZA;Aa3XA;;AAAA;;;;;;AjCJA;AiCmsBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;AarMA;;AAAA;;;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;;;;;AW1GA;;;A/B/FA;A+B4FA;AA+CA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;;AAMA;AArDA;;A/B/FA;A+B4FA;AAyDA;AAAA;;AAIA;;;;;AAHA;;AXmPA;;;;;AAEA;;;;;AAZA;Aa3XA;;AAAA;;;;;;AjCJA;AiCmsBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;AarMA;;AAAA;;;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;;;;AWzDA;;AXyPA;;;;;AAEA;;;;;AAZA;Aa3XA;;AAAA;;;;;;AjCJA;AiCmsBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;AarMA;;AAAA;;;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;;;;;AW1GA;;;A/B/FA;A+B4FA;AAiEA;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;AAMA;AAtEA;;A/B/FA;A+B4FA;AA0EA;AAAA;;AAIA;AA3EA;;A/B/FA;A+B4FA;AA+EA;AAAA;;AAIA;;;;;AAHA;;AX6NA;;;;;AAEA;;;;;AAZA;Aa3XA;;AAAA;;;;;;AjCJA;AiCmsBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;AarMA;;AAAA;;;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;;;;AWlCA;;AXkOA;;;;;AAEA;;;;;AAZA;Aa3XA;;AAAA;;;;;;AjCJA;AiCmsBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;AarMA;;AAAA;;;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;;;;AWxCA;;AXwOA;;;;;AAEA;;;;;AAZA;Aa3XA;;AAAA;;;;;;AjCJA;AiCmsBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;AarMA;;AAAA;;;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;;;;;AWvBA;;AXuNA;;;;;AAEA;;;;;AAZA;Aa3XA;;AAAA;;;;;;AjCJA;AiCmsBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;AarMA;;AAAA;;;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;;;;;;AW5FA;;;;;;;;;;;AX6RA;;;;;;;AAEA;;;;;;;AAFA;;;;;;;AAEA;;;;;;;AAFA;;;;;;;AAEA;;;;;;;AAFA;;;;;;;AAEA;;;;;;;AAFA;;;;;;;AAEA;;;;;;;AAFA;;;;;;;AAEA;;;;;;;AAFA;;;;;;;AAEA;;;;;;;;;;AWpNA;;AXuMA;Aa3XA;;AAAA;;;;;;AjCJA;AiCmsBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;;AWdA;AAAA;AAAA;AACA;;;;;AjBrFA;AAAA;;;;;AAvZA;AezBA;;;;;;;;;;;;;AfyBA;AmBg/CA;AAAA;AgBnoDA;;ACDA;AAAA;;ApCiGA;;;;Ae1CA;A7B8eA;;Ac1bA;AAAA;;;;;AAKA;AmBkPA;AAAA;AAAA;AAAA;AAAA;;AAsGA;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;AvB5eA;AkCs3CA;AACA;;;;AjB7+BA;AAAA;;;;;AAvZA;AezBA;;;;;;;;;;AE85DA;AACA;;;;;;;AAxwCA;AA20CA;;;;;;;;;;;AkB5lEA;;ACDA;AAAA;;ApCiGA;;;;Ae1CA;A7B8eA;;Ac1bA;AAAA;;;;;AAKA;AmBkPA;AAAA;AAAA;AAAA;AAAA;;AAsGA;;;;AA+rBA;AAitBA;AAnrCA;AnBjhBA;AdidA;AoBwCA;AvB5eA;AoCq7DA;;;;AnB3iDA;AAAA;;;;;AAvZA;AezBA;;;;;;;AVmyCA;AkE13CA;AACA;AAAA;;;;;AAvBA;AAAA;;;;;;AlEguBA;AAoqBA;AkEl2CA;;;;;;AC4IA;AAC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","sourcesContent":["use std::marker::PhantomData;\nuse std::mem;\nuse std::ops::{Deref, DerefMut};\nuse std::path::Path;\nuse std::rc::Rc;\n\nuse rect::Rect;\nuse get_error;\nuse std::ptr;\nuse libc::c_int;\nuse num::FromPrimitive;\nuse pixels;\nuse render::{BlendMode, Canvas};\nuse rwops::RWops;\n\nuse sys::surface as ll;\n\n/// Holds a `SDL_Surface`\n///\n/// When the `SurfaceContext` is dropped, it frees the `SDL_Surface`\n///\n/// *INTERNAL USE ONLY*\npub struct SurfaceContext<'a> {\n    raw: *mut ll::SDL_Surface,\n    _marker: PhantomData<&'a ()>\n}\n\nimpl<'a> Drop for SurfaceContext<'a> {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe { ll::SDL_FreeSurface(self.raw); }\n    }\n}\n\n/// Holds a `Rc<SurfaceContext>`.\n///\n/// Note: If a `Surface` goes out of scope but it cloned its context,\n/// then the `SDL_Surface` will not be free'd until there are no more references to the `SurfaceContext`.\npub struct Surface<'a> {\n    context: Rc<SurfaceContext<'a>>,\n}\n\n/// An unsized Surface reference.\n///\n/// This type is used whenever Surfaces need to be borrowed from the SDL library, without concern\n/// for freeing the Surface.\npub struct SurfaceRef {\n    // It's nothing! (it gets transmuted to SDL_Surface later).\n    // The empty private field is need to a) make `std::mem::swap()` copy nothing instead of\n    // clobbering two surfaces (SDL_Surface's size could change in the future),\n    // and b) prevent user initialization of this type.\n    _raw: ()\n}\n\nimpl AsRef<SurfaceRef> for SurfaceRef  {\n    fn as_ref(&self) -> &SurfaceRef {\n        self\n    }\n}\n\n#[test]\nfn test_surface_ref_size() {\n    // `SurfaceRef` must be 0 bytes.\n    assert_eq!(::std::mem::size_of::<SurfaceRef>(), 0);\n}\n\nimpl<'a> Deref for Surface<'a> {\n    type Target = SurfaceRef;\n\n    #[inline]\n    fn deref(&self) -> &SurfaceRef {\n        unsafe { mem::transmute(self.context.raw) }\n    }\n}\n\nimpl<'a> DerefMut for Surface<'a> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut SurfaceRef {\n        unsafe { mem::transmute(self.context.raw) }\n    }\n}\n\nimpl<'a> AsRef<SurfaceRef> for Surface<'a> {\n    #[inline]\n    fn as_ref(&self) -> &SurfaceRef {\n        unsafe { mem::transmute(self.context.raw) }\n    }\n}\n\nimpl<'a> AsMut<SurfaceRef> for Surface<'a> {\n    #[inline]\n    fn as_mut(&mut self) -> &mut SurfaceRef {\n        unsafe { mem::transmute(self.context.raw) }\n    }\n}\n\n\nimpl<'a> Surface<'a> {\n    pub unsafe fn from_ll<'b>(raw: *mut ll::SDL_Surface) -> Surface<'b> {\n        let context = SurfaceContext {\n            raw: raw,\n            _marker: PhantomData,\n        };\n        Surface { context: Rc::new(context) }\n    }\n\n    /// Creates a new surface using a pixel format.\n    ///\n    /// # Example\n    /// ```no_run\n    /// use sdl2::pixels::PixelFormatEnum;\n    /// use sdl2::surface::Surface;\n    ///\n    /// let surface = Surface::new(512, 512, PixelFormatEnum::RGB24).unwrap();\n    /// ```\n    pub fn new(width: u32, height: u32, format: pixels::PixelFormatEnum) -> Result<Surface<'static>, String> {\n        let masks = try!(format.into_masks());\n        Surface::from_pixelmasks(width, height, masks)\n    }\n\n    /// Creates a new surface using pixel masks.\n    ///\n    /// # Example\n    /// ```no_run\n    /// use sdl2::pixels::PixelFormatEnum;\n    /// use sdl2::surface::Surface;\n    ///\n    /// let masks = PixelFormatEnum::RGB24.into_masks().unwrap();\n    /// let surface = Surface::from_pixelmasks(512, 512, masks).unwrap();\n    /// ```\n    pub fn from_pixelmasks(width: u32, height: u32, masks: pixels::PixelMasks) -> Result<Surface<'static>, String> {\n        unsafe {\n            if width >= (1<<31) || height >= (1<<31) {\n                Err(\"Image is too large.\".to_owned())\n            } else {\n                let raw = ll::SDL_CreateRGBSurface(0, width as c_int, height as c_int,\n                    masks.bpp as c_int, masks.rmask, masks.gmask, masks.bmask, masks.amask);\n\n                if raw.is_null() {\n                    Err(get_error())\n                } else {\n                    Ok(Surface::from_ll(raw))\n                }\n            }\n        }\n    }\n\n    /// Creates a new surface from an existing buffer, using a pixel format.\n    pub fn from_data(data: &'a mut [u8], width: u32, height: u32, pitch: u32, format: pixels::PixelFormatEnum) -> Result<Surface<'a>, String> {\n        let masks = try!(format.into_masks());\n        Surface::from_data_pixelmasks(data, width, height, pitch, masks)\n    }\n\n    /// Creates a new surface from an existing buffer, using pixel masks.\n    pub fn from_data_pixelmasks(data: &'a mut [u8], width: u32, height: u32, pitch: u32, masks: pixels::PixelMasks) -> Result<Surface<'a>, String> {\n        unsafe {\n            if width >= (1<<31) || height >= (1<<31) {\n                Err(\"Image is too large.\".to_owned())\n            } else if pitch >= (1<<31) {\n                Err(\"Pitch is too large.\".to_owned())\n            } else {\n                let raw = ll::SDL_CreateRGBSurfaceFrom(\n                    data.as_mut_ptr() as *mut _, width as c_int, height as c_int,\n                    masks.bpp as c_int, pitch as c_int, masks.rmask, masks.gmask, masks.bmask, masks.amask);\n\n                if raw.is_null() {\n                    Err(get_error())\n                } else {\n                    Ok(Surface::from_ll(raw))\n                }\n            }\n        }\n    }\n\n    pub fn load_bmp_rw(rwops: &mut RWops) -> Result<Surface<'static>, String> {\n        let raw = unsafe {\n            ll::SDL_LoadBMP_RW(rwops.raw(), 0)\n        };\n\n        if raw.is_null() {\n            Err(get_error())\n        } else {\n            Ok( unsafe{ Surface::from_ll(raw) } )\n        }\n    }\n\n    pub fn load_bmp<P: AsRef<Path>>(path: P) -> Result<Surface<'static>, String> {\n        let mut file = try!(RWops::from_file(path, \"rb\"));\n        Surface::load_bmp_rw(&mut file)\n    }\n\n    /// Creates a Software Canvas to allow rendering in the Surface itself. This `Canvas` will\n    /// never be accelerated materially, so there is no performance change between `Surface` and\n    /// `Canvas` coming from a `Surface`.\n    ///\n    /// The only change is this case is that `Canvas` has a\n    /// better API to draw stuff in the `Surface` in that case, but don't expect any performance\n    /// changes, there will be none.\n    pub fn into_canvas(self) -> Result<Canvas<Surface<'a>>, String> {\n        Canvas::from_surface(self)\n    }\n\n    pub fn context(&self) -> Rc<SurfaceContext<'a>> {\n        self.context.clone()\n    }\n}\n\nimpl SurfaceRef {\n    #[inline]\n    pub unsafe fn from_ll<'a>(raw: *const ll::SDL_Surface) -> &'a SurfaceRef {\n        &*(raw as *const () as *const SurfaceRef)\n    }\n\n    #[inline]\n    pub unsafe fn from_ll_mut<'a>(raw: *mut ll::SDL_Surface) -> &'a mut SurfaceRef {\n        &mut *(raw as *mut () as *mut SurfaceRef)\n    }\n\n    #[inline]\n    pub fn raw(&self) -> *mut ll::SDL_Surface {\n        self as *const SurfaceRef as *mut SurfaceRef as *mut () as *mut ll::SDL_Surface\n    }\n\n    #[inline]\n    fn raw_ref(&self) -> &ll::SDL_Surface {\n        unsafe {\n            &*(self as *const _ as *const () as *const ll::SDL_Surface)\n        }\n    }\n\n    pub fn width(&self) -> u32 {\n        self.raw_ref().w as u32\n    }\n\n    pub fn height(&self) -> u32 {\n        self.raw_ref().h as u32\n    }\n\n    pub fn pitch(&self) -> u32 {\n        self.raw_ref().pitch as u32\n    }\n\n    pub fn size(&self) -> (u32, u32) {\n        (self.width(), self.height())\n    }\n\n    pub fn rect(&self) -> Rect {\n        Rect::new(0, 0, self.width(), self.height())\n    }\n\n    pub fn pixel_format(&self) -> pixels::PixelFormat {\n        unsafe {\n            pixels::PixelFormat::from_ll(self.raw_ref().format)\n        }\n    }\n\n    pub fn pixel_format_enum(&self) -> pixels::PixelFormatEnum {\n        pixels::PixelFormatEnum::from(self.pixel_format())\n    }\n\n    /// Locks a surface so that the pixels can be directly accessed safely.\n    pub fn with_lock<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {\n        unsafe {\n            if ll::SDL_LockSurface(self.raw()) != 0 { panic!(\"could not lock surface\"); }\n\n            let raw_pixels = self.raw_ref().pixels as *const _;\n            let len = self.raw_ref().pitch as usize * (self.raw_ref().h as usize);\n            let pixels = ::std::slice::from_raw_parts(raw_pixels, len);\n            let rv = f(pixels);\n            ll::SDL_UnlockSurface(self.raw());\n            rv\n        }\n    }\n\n    /// Locks a surface so that the pixels can be directly accessed safely.\n    pub fn with_lock_mut<R, F: FnOnce(&mut [u8]) -> R>(&mut self, f: F) -> R {\n        unsafe {\n            if ll::SDL_LockSurface(self.raw()) != 0 { panic!(\"could not lock surface\"); }\n\n            let raw_pixels = self.raw_ref().pixels as *mut _;\n            let len = self.raw_ref().pitch as usize * (self.raw_ref().h as usize);\n            let pixels = ::std::slice::from_raw_parts_mut(raw_pixels, len);\n            let rv = f(pixels);\n            ll::SDL_UnlockSurface(self.raw());\n            rv\n        }\n    }\n\n    /// Returns the Surface's pixel buffer if the Surface doesn't require locking\n    /// (e.g. it's a software surface).\n    pub fn without_lock(&self) -> Option<&[u8]> {\n        if self.must_lock() {\n            None\n        } else {\n            unsafe {\n                let raw_pixels = self.raw_ref().pixels as *const _;\n                let len = self.raw_ref().pitch as usize * (self.raw_ref().h as usize);\n\n                Some(::std::slice::from_raw_parts(raw_pixels, len))\n            }\n        }\n    }\n\n    /// Returns the Surface's pixel buffer if the Surface doesn't require locking\n    /// (e.g. it's a software surface).\n    pub fn without_lock_mut(&mut self) -> Option<&mut [u8]> {\n        if self.must_lock() {\n            None\n        } else {\n            unsafe {\n                let raw_pixels = self.raw_ref().pixels as *mut _;\n                let len = self.raw_ref().pitch as usize * (self.raw_ref().h as usize);\n\n                Some(::std::slice::from_raw_parts_mut(raw_pixels, len))\n            }\n        }\n    }\n\n    /// Returns true if the Surface needs to be locked before accessing the Surface pixels.\n    pub fn must_lock(&self) -> bool {\n        // Implements the SDL_MUSTLOCK macro.\n        (self.raw_ref().flags & ll::SDL_RLEACCEL) != 0\n    }\n\n    pub fn save_bmp_rw(&self, rwops: &mut RWops) -> Result<(), String> {\n        let ret = unsafe {\n            ll::SDL_SaveBMP_RW(self.raw(), rwops.raw(), 0)\n        };\n        if ret == 0 { Ok(()) }\n        else { Err(get_error()) }\n    }\n\n    pub fn save_bmp<P: AsRef<Path>>(&self, path: P) -> Result<(), String> {\n        let mut file = try!(RWops::from_file(path, \"wb\"));\n        self.save_bmp_rw(&mut file)\n    }\n\n    pub fn set_palette(&mut self, palette: &pixels::Palette) -> Result<(), String> {\n        let result = unsafe { ll::SDL_SetSurfacePalette(self.raw(), palette.raw()) };\n\n        match result {\n            0 => Ok(()),\n            _ => Err(get_error())\n        }\n    }\n\n    #[allow(non_snake_case)]\n    pub fn enable_RLE(&mut self) {\n        let result = unsafe { ll::SDL_SetSurfaceRLE(self.raw(), 1) };\n\n        if result != 0 {\n            // Should only panic on a null Surface\n            panic!(get_error());\n        }\n    }\n\n    #[allow(non_snake_case)]\n    pub fn disable_RLE(&mut self) {\n        let result = unsafe { ll::SDL_SetSurfaceRLE(self.raw(), 0) };\n\n        if result != 0 {\n            // Should only panic on a null Surface\n            panic!(get_error());\n        }\n    }\n\n    pub fn set_color_key(&mut self, enable: bool, color: pixels::Color) -> Result<(), String> {\n        let key = color.to_u32(&self.pixel_format());\n        let result = unsafe {\n            ll::SDL_SetColorKey(self.raw(), if enable { 1 } else { 0 }, key)\n        };\n        if result == 0 {\n            Ok(())\n        } else {\n            Err(get_error())\n        }\n    }\n\n    /// The function will fail if the surface doesn't have color key enabled.\n    pub fn color_key(&self) -> Result<pixels::Color, String> {\n        let mut key = 0;\n\n        // SDL_GetColorKey does not mutate, but requires a non-const pointer anyway.\n\n        let result = unsafe {\n            ll::SDL_GetColorKey(self.raw(), &mut key)\n        };\n\n        if result == 0 {\n            Ok(pixels::Color::from_u32(&self.pixel_format(), key))\n        } else {\n            Err(get_error())\n        }\n    }\n\n    pub fn set_color_mod(&mut self, color: pixels::Color) {\n        let (r, g, b) = color.rgb();\n        let result = unsafe { ll::SDL_SetSurfaceColorMod(self.raw(), r, g, b) };\n\n        if result != 0 {\n            // Should only fail on a null Surface\n            panic!(get_error());\n        }\n    }\n\n    pub fn color_mod(&self) -> pixels::Color {\n        let mut r = 0;\n        let mut g = 0;\n        let mut b = 0;\n\n        // SDL_GetSurfaceColorMod does not mutate, but requires a non-const pointer anyway.\n\n        let result = unsafe {\n            ll::SDL_GetSurfaceColorMod(self.raw(), &mut r, &mut g, &mut b) == 0\n        };\n\n        if result {\n            pixels::Color::RGB(r, g, b)\n        } else {\n            // Should only fail on a null Surface\n            panic!(get_error())\n        }\n    }\n\n    pub fn fill_rect<R>(&mut self, rect: R, color: pixels::Color) -> Result<(), String>\n    where R: Into<Option<Rect>>\n    {\n        unsafe {\n            let rect = rect.into();\n            let rect_ptr = mem::transmute(rect.as_ref()); // TODO find a better way to transform\n            // Option<&...> into a *const _\n            let format = self.pixel_format();\n            let result = ll::SDL_FillRect(self.raw(), rect_ptr, color.to_u32(&format) );\n            match result {\n                0 => Ok(()),\n                _ => Err(get_error())\n            }\n        }\n    }\n\n    pub fn fill_rects(&mut self, rects: &[Rect], color: pixels::Color) -> Result<(), String>\n    {\n        for rect in rects.iter() {\n            let result = self.fill_rect(rect.clone(), color);\n            match result {\n                Err(e) => return Err(e),\n                _ => ()\n            };\n        }\n\n        Ok(())\n    }\n\n    pub fn set_alpha_mod(&mut self, alpha: u8) {\n        let result = unsafe {\n            ll::SDL_SetSurfaceAlphaMod(self.raw(), alpha)\n        };\n\n        if result != 0 {\n            // Should only fail on a null Surface\n            panic!(get_error());\n        }\n    }\n\n    pub fn alpha_mod(&self) -> u8 {\n        let mut alpha = 0;\n        let result = unsafe {\n            ll::SDL_GetSurfaceAlphaMod(self.raw(), &mut alpha)\n        };\n\n        match result {\n            0 => alpha,\n            // Should only fail on a null Surface\n            _ => panic!(get_error())\n        }\n    }\n\n    /// The function will fail if the blend mode is not supported by SDL.\n    pub fn set_blend_mode(&mut self, mode: BlendMode) -> Result<(), String> {\n        let result = unsafe {\n            ll::SDL_SetSurfaceBlendMode(self.raw(), mode as c_int)\n        };\n\n        match result {\n            0 => Ok(()),\n            _ => Err(get_error())\n        }\n    }\n\n    pub fn blend_mode(&self) -> BlendMode {\n        let mut mode: ::sys::SDL_BlendMode = 0;\n        let result = unsafe {\n            ll::SDL_GetSurfaceBlendMode(self.raw(), &mut mode)\n        };\n\n        match result {\n            0 => FromPrimitive::from_i32(mode as i32).unwrap(),\n            // Should only fail on a null Surface\n            _ => panic!(get_error())\n        }\n    }\n\n    /// Sets the clip rectangle for the surface.\n    ///\n    /// If the rectangle is `None`, clipping will be disabled.\n    pub fn set_clip_rect<R>(&mut self, rect: R) -> bool \n    where R: Into<Option<Rect>>\n    {\n        let rect = rect.into();\n        unsafe {\n            ll::SDL_SetClipRect(self.raw(), match rect {\n                Some(rect) => rect.raw(),\n                None => ptr::null()\n            }) == 1\n        }\n    }\n\n    /// Gets the clip rectangle for the surface.\n    ///\n    /// Returns `None` if clipping is disabled.\n    pub fn clip_rect(&self) -> Option<Rect> {\n        let mut raw = unsafe { mem::uninitialized() };\n        unsafe {\n            ll::SDL_GetClipRect(self.raw(), &mut raw)\n        };\n        if raw.w == 0 || raw.h == 0 {\n            None\n        } else {\n            Some(Rect::from_ll(raw))\n        }\n    }\n\n    /// Copies the surface into a new one that is optimized for blitting to a surface of a specified pixel format.\n    pub fn convert(&self, format: &pixels::PixelFormat) -> Result<Surface<'static>, String> {\n        // SDL_ConvertSurface takes a flag as the last parameter, which should be 0 by the docs.\n        let surface_ptr = unsafe { ll::SDL_ConvertSurface(self.raw(), format.raw(), 0u32) };\n\n        if surface_ptr.is_null() {\n            Err(get_error())\n        } else {\n            unsafe { Ok(Surface::from_ll(surface_ptr)) }\n        }\n    }\n\n    // Note: There's no need to implement SDL_ConvertSurfaceFormat, as it\n    // does the same thing as SDL_ConvertSurface but with a slightly different\n    // function signature.\n\n    /// Performs surface blitting (surface copying).\n    ///\n    /// Returns the final blit rectangle, if a `dst_rect` was provided.\n    pub fn blit<R1, R2>(&self, src_rect: R1,\n            dst: &mut SurfaceRef, dst_rect: R2)\n            -> Result<Option<Rect>, String> \n        where R1: Into<Option<Rect>>,\n              R2: Into<Option<Rect>>,\n    {\n        let src_rect = src_rect.into();\n        let dst_rect = dst_rect.into();\n\n        unsafe {\n            let src_rect_ptr = src_rect.as_ref().map(|r| r.raw()).unwrap_or(ptr::null());\n\n            // Copy the rect here to make a mutable copy without requiring\n            // a mutable argument\n            let mut dst_rect = dst_rect;\n            let dst_rect_ptr = dst_rect.as_mut().map(|mut r| r.raw_mut())\n                .unwrap_or(ptr::null_mut());\n            let result = ll::SDL_UpperBlit(\n                self.raw(), src_rect_ptr, dst.raw(), dst_rect_ptr\n            );\n\n            if result == 0 {\n                Ok(dst_rect)\n            } else {\n                Err(get_error())\n            }\n        }\n    }\n\n    /// Performs low-level surface blitting.\n    ///\n    /// Unless you know what you're doing, use `blit()` instead, which will clip the input rectangles.\n    /// This function could crash if the rectangles aren't pre-clipped to the surface, and is therefore unsafe.\n    pub unsafe fn lower_blit<R1, R2>(&self, src_rect: R1,\n                      dst: &mut SurfaceRef, dst_rect: R2) -> Result<(), String> \n    where R1: Into<Option<Rect>>,\n          R2: Into<Option<Rect>>,\n    {\n        let src_rect = src_rect.into();\n        let dst_rect = dst_rect.into();\n\n        match {\n            // The rectangles don't change, but the function requires mutable pointers.\n            let src_rect_ptr = src_rect.as_ref().map(|r| r.raw())\n                .unwrap_or(ptr::null()) as *mut _;\n            let dst_rect_ptr = dst_rect.as_ref().map(|r| r.raw())\n                .unwrap_or(ptr::null()) as *mut _;\n            ll::SDL_LowerBlit(self.raw(), src_rect_ptr, dst.raw(), dst_rect_ptr)\n        } {\n            0 => Ok(()),\n            _ => Err(get_error())\n        }\n    }\n\n    /// Performs scaled surface bliting (surface copying).\n    ///\n    /// Returns the final blit rectangle, if a `dst_rect` was provided.\n    pub fn blit_scaled<R1, R2>(&self, src_rect: R1,\n                             dst: &mut SurfaceRef, dst_rect: R2) -> Result<Option<Rect>, String> \n    where R1: Into<Option<Rect>>,\n          R2: Into<Option<Rect>>,\n    {\n        let src_rect = src_rect.into();\n        let dst_rect = dst_rect.into();\n\n        match unsafe {\n            let src_rect_ptr = src_rect.as_ref().map(|r| r.raw()).unwrap_or(ptr::null());\n\n            // Copy the rect here to make a mutable copy without requiring\n            // a mutable argument\n            let mut dst_rect = dst_rect;\n            let dst_rect_ptr = dst_rect.as_mut().map(|mut r| r.raw_mut())\n                .unwrap_or(ptr::null_mut());\n            ll::SDL_UpperBlitScaled(self.raw(), src_rect_ptr, dst.raw(), dst_rect_ptr)\n        } {\n            0 => Ok(dst_rect),\n            _ => Err(get_error())\n        }\n    }\n\n    /// Performs low-level scaled surface blitting.\n    ///\n    /// Unless you know what you're doing, use `blit_scaled()` instead, which will clip the input rectangles.\n    /// This function could crash if the rectangles aren't pre-clipped to the surface, and is therefore unsafe.\n    pub unsafe fn lower_blit_scaled<R1, R2>(&self, src_rect: R1,\n                             dst: &mut SurfaceRef, dst_rect: R2) -> Result<(), String> \n    where R1: Into<Option<Rect>>,\n          R2: Into<Option<Rect>>\n    {\n\n        match {\n            // The rectangles don't change, but the function requires mutable pointers.\n            let src_rect_ptr = src_rect.into().as_ref().map(|r| r.raw())\n                .unwrap_or(ptr::null()) as *mut _;\n            let dst_rect_ptr = dst_rect.into().as_ref().map(|r| r.raw())\n                .unwrap_or(ptr::null()) as *mut _;\n            ll::SDL_LowerBlitScaled(self.raw(), src_rect_ptr, dst.raw(), dst_rect_ptr)\n        } {\n            0 => Ok(()),\n            _ => Err(get_error())\n        }\n    }\n\n    /*\n    pub fn SDL_ConvertPixels(width: c_int, height: c_int, src_format: uint32_t, src: *c_void, src_pitch: c_int, dst_format: uint32_t, dst: *c_void, dst_pitch: c_int) -> c_int;\n    */\n}\n",null,null,null,null,null,null,null,null,null,"//! 2D accelerated rendering\n//!\n//! Official C documentation: https://wiki.libsdl.org/CategoryRender\n//! # Introduction\n//!\n//! This module contains functions for 2D accelerated rendering.\n//!\n//! This API supports the following features:\n//!\n//! * single pixel points\n//! * single pixel lines\n//! * filled rectangles\n//! * texture images\n//! * All of these may be drawn in opaque, blended, or additive modes.\n//!\n//! The texture images can have an additional color tint or alpha modulation\n//! applied to them, and may also be stretched with linear interpolation,\n//! rotated or flipped/mirrored.\n//!\n//! For advanced functionality like particle effects or actual 3D you should use\n//! SDL's OpenGL/Direct3D support or one of the many available 3D engines.\n//!\n//! This API is not designed to be used from multiple threads, see\n//! [this bug](http://bugzilla.libsdl.org/show_bug.cgi?id=1995) for details.\n//!\n//! ---\n//!\n//! None of the draw methods in `Canvas` are expected to fail.\n//! If they do, a panic is raised and the program is aborted.\n\nuse video::{Window, WindowContext};\nuse surface;\nuse surface::{Surface, SurfaceRef, SurfaceContext};\nuse pixels;\nuse pixels::PixelFormatEnum;\nuse get_error;\nuse std::fmt;\nuse std::error::Error;\nuse std::marker::PhantomData;\nuse std::mem;\nuse std::ops::Deref;\nuse std::ptr;\nuse std::rc::Rc;\nuse libc::{c_int, uint32_t, c_double, c_void};\nuse rect::Point;\nuse rect::Rect;\nuse std::ffi::CStr;\nuse num::FromPrimitive;\nuse std::vec::Vec;\nuse common::{validate_int, IntegerOrSdlError};\n\nuse sys::render as ll;\n\n/// Contains the description of an error returned by SDL\n#[derive(Debug)]\npub struct SdlError(String);\n\n/// Possible errors returned by targetting a `Canvas` to render to a `Texture`\n#[derive(Debug)]\npub enum TargetRenderError {\n    SdlError(SdlError),\n    NotSupported,\n}\n\nimpl fmt::Display for SdlError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let &SdlError(ref e) = self;\n        write!(f, \"SDL error: {}\", e)\n    }\n}\n\nimpl Error for SdlError {\n    fn description(&self) -> &str {\n        let &SdlError(ref e) = self;\n        e\n    }\n}\n\nimpl fmt::Display for TargetRenderError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::TargetRenderError::*;\n        match *self {\n            SdlError(ref e) => e.fmt(f),\n            NotSupported => write!(f, \"The renderer does not support the use of render targets\"),\n        }\n    }\n}\n\nimpl Error for TargetRenderError {\n    fn description(&self) -> &str {\n        use self::TargetRenderError::*;\n        match *self {\n            SdlError(ref e) => e.description(),\n            NotSupported => \"The renderer does not support the use of render targets\",\n        }\n    }\n}\n\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n#[repr(i32)]\npub enum TextureAccess {\n    Static = ll::SDL_TEXTUREACCESS_STATIC as i32,\n    Streaming = ll::SDL_TEXTUREACCESS_STREAMING as i32,\n    Target = ll::SDL_TEXTUREACCESS_TARGET as i32,\n}\n\nimpl FromPrimitive for TextureAccess {\n    fn from_i64(n: i64) -> Option<TextureAccess> {\n        use self::TextureAccess::*;\n\n        Some(match n as ll::SDL_TextureAccess {\n                 ll::SDL_TEXTUREACCESS_STATIC => Static,\n                 ll::SDL_TEXTUREACCESS_STREAMING => Streaming,\n                 ll::SDL_TEXTUREACCESS_TARGET => Target,\n                 _ => return None,\n             })\n    }\n\n    fn from_u64(n: u64) -> Option<TextureAccess> {\n        FromPrimitive::from_i64(n as i64)\n    }\n}\n\n/// A structure that contains information on the capabilities of a render driver\n/// or the current render context.\n#[derive(Clone, Eq, PartialEq, Hash, Debug)]\npub struct RendererInfo {\n    pub name: &'static str,\n    pub flags: u32,\n    pub texture_formats: Vec<PixelFormatEnum>,\n    pub max_texture_width: u32,\n    pub max_texture_height: u32,\n}\n\n#[repr(i32)]\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\npub enum BlendMode {\n    None = ll::SDL_BLENDMODE_NONE as i32,\n    Blend = ll::SDL_BLENDMODE_BLEND as i32,\n    Add = ll::SDL_BLENDMODE_ADD as i32,\n    Mod = ll::SDL_BLENDMODE_MOD as i32,\n}\n\nimpl FromPrimitive for BlendMode {\n    fn from_i64(n: i64) -> Option<BlendMode> {\n        use self::BlendMode::*;\n\n        Some(match n as ll::SDL_BlendMode {\n                 ll::SDL_BLENDMODE_NONE => None,\n                 ll::SDL_BLENDMODE_BLEND => Blend,\n                 ll::SDL_BLENDMODE_ADD => Add,\n                 ll::SDL_BLENDMODE_MOD => Mod,\n                 _ => return Option::None,\n             })\n    }\n\n    fn from_u64(n: u64) -> Option<BlendMode> {\n        FromPrimitive::from_i64(n as i64)\n    }\n}\n\nimpl RendererInfo {\n    pub unsafe fn from_ll(info: &ll::SDL_RendererInfo) -> RendererInfo {\n        let texture_formats: Vec<PixelFormatEnum> =\n            info.texture_formats[0..(info.num_texture_formats as usize)]\n                .iter()\n                .map(|&format| {\n                         PixelFormatEnum::from_i64(format as i64)\n                             .unwrap_or(PixelFormatEnum::Unknown)\n                     })\n                .collect();\n\n        // The driver name is always a static string, compiled into SDL2.\n        let name = CStr::from_ptr(info.name as *const _).to_str().unwrap();\n\n        RendererInfo {\n            name: name,\n            flags: info.flags,\n            texture_formats: texture_formats,\n            max_texture_width: info.max_texture_width as u32,\n            max_texture_height: info.max_texture_height as u32,\n        }\n    }\n}\n\n/// Manages what keeps a SDL_Renderer alive\n///\n/// When the `RendererContext` is dropped, it destroys the `SDL_Renderer`\npub struct RendererContext<T> {\n    raw: *mut ll::SDL_Renderer,\n    _target: Rc<T>,\n}\n\nimpl<T> Drop for RendererContext<T> {\n    fn drop(&mut self) {\n        unsafe {\n            ll::SDL_DestroyRenderer(self.raw);\n        };\n    }\n}\n\nimpl<T> RendererContext<T> {\n    /// Gets information about the rendering context.\n    pub fn info(&self) -> RendererInfo {\n        unsafe {\n            let mut renderer_info_raw = mem::uninitialized();\n            if ll::SDL_GetRendererInfo(self.raw, &mut renderer_info_raw) != 0 {\n                // Should only fail on an invalid renderer\n                panic!();\n            } else {\n                RendererInfo::from_ll(&renderer_info_raw)\n            }\n        }\n    }\n\n    /// Gets the raw pointer to the SDL_Renderer\n    pub fn raw(&self) -> *mut ll::SDL_Renderer {\n        self.raw\n    }\n\n    pub unsafe fn from_ll(raw: *mut ll::SDL_Renderer, target: Rc<T>) -> Self {\n        RendererContext {\n            raw: raw,\n            _target: target,\n        }\n    }\n\n    unsafe fn set_raw_target(&self, raw_texture: *mut ll::SDL_Texture) -> Result<(), SdlError> {\n        if ll::SDL_SetRenderTarget(self.raw, raw_texture) == 0 {\n            Ok(())\n        } else {\n            Err(SdlError(get_error()))\n        }\n    }\n}\n\nimpl<T: RenderTarget> Deref for Canvas<T> {\n    type Target = RendererContext<T::Context>;\n\n    fn deref(&self) -> &RendererContext<T::Context> {\n        self.context.as_ref()\n    }\n}\n\n/// Represents structs which can be the target of a SDL_Renderer (or Canvas).\n///\n/// This is intended for internal use only. It should not be used outside of this crate,\n/// but is still visible for documentation reasons.\npub trait RenderTarget {\n    type Context;\n}\n\nimpl<'s> RenderTarget for Surface<'s> {\n    type Context = SurfaceContext<'s>;\n}\n\n/// Manages and owns a target (`Surface` or `Window`) and allows drawing in it.\n///\n/// If the `Window` manipulates the shell of the Window, `Canvas<Window>` allows you to\n/// manipulate both the shell and the inside of the window;\n/// you can manipulate pixel by pixel (*not recommended*), lines, colored rectangles, or paste\n/// `Texture`s to this `Canvas`.\n///\n/// Drawing to the `Canvas` does not take effect immediately, it draws to a buffer until you\n/// call `present()`, where all the operations you did until the last `present()`\n/// are updated to your target\n///\n/// Its context may be shared with the `TextureCreator`.\n///\n/// The context will not be dropped until all references of it are out of scope.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use sdl2::render::Canvas;\n/// # use sdl2::video::Window;\n/// # use sdl2::pixels::Color;\n/// # use sdl2::rect::Rect;\n/// # let sdl_context = sdl2::init().unwrap();\n/// # let video_subsystem = sdl_context.video().unwrap();\n/// let window = video_subsystem.window(\"Example\", 800, 600).build().unwrap();\n///\n/// // Let's create a Canvas which we will use to draw in our Window\n/// let mut canvas : Canvas<Window> = window.into_canvas()\n///     .present_vsync() //< this means the screen cannot\n///     // render faster than your display rate (usually 60Hz or 144Hz)\n///     .build().unwrap();\n///\n/// canvas.set_draw_color(Color::RGB(0, 0, 0));\n/// // fills the canvas with the color we set in `set_draw_color`.\n/// canvas.clear();\n///\n/// // change the color of our drawing with a gold-color ...\n/// canvas.set_draw_color(Color::RGB(255, 210, 0));\n/// // A draw a rectangle which almost fills our window with it !\n/// canvas.fill_rect(Rect::new(10, 10, 780, 580));\n///\n/// // However the canvas has not been updated to the window yet,\n/// // everything has been processed to an internal buffer,\n/// // but if we want our buffer to be displayed on the window,\n/// // we need to call `present`. We need to call this everytime\n/// // we want to render a new frame on the window.\n/// canvas.present();\n/// // present does not \"clear\" the buffer, that means that\n/// // you have to clear it yourself before rendering again,\n/// // otherwise leftovers of what you've renderer before might\n/// // show up on the window !\n/// //\n/// // A good rule of thumb is to `clear()`, draw every texture\n/// // needed, and then `present()`; repeat this every new frame.\n///\n/// ```\npub struct Canvas<T: RenderTarget> {\n    target: T,\n    context: Rc<RendererContext<T::Context>>,\n}\n\n/// Alias for a `Canvas` that was created out of a `Surface`\npub type SurfaceCanvas<'s> = Canvas<Surface<'s>>;\n\n/// Methods for the `SurfaceCanvas`.\nimpl<'s> Canvas<Surface<'s>> {\n    /// Creates a 2D software rendering context for a surface.\n    ///\n    /// This method should only fail if SDL2 is not built with rendering\n    /// support, or there's an out-of-memory error.\n    pub fn from_surface(surface: surface::Surface<'s>) -> Result<Self, String> {\n        let raw_renderer = unsafe { ll::SDL_CreateSoftwareRenderer(surface.raw()) };\n        if !raw_renderer.is_null() {\n            let context =\n                Rc::new(unsafe { RendererContext::from_ll(raw_renderer, surface.context()) });\n            Ok(Canvas {\n                   target: surface,\n                   context: context,\n               })\n        } else {\n            Err(get_error())\n        }\n    }\n\n    /// Gets a reference to the associated surface of the Canvas\n    #[inline]\n    pub fn surface(&self) -> &SurfaceRef {\n        &self.target\n    }\n\n    /// Gets a mutable reference to the associated surface of the Canvas\n    #[inline]\n    pub fn surface_mut(&mut self) -> &mut SurfaceRef {\n        &mut self.target\n    }\n\n    /// Gets the associated surface of the Canvas and destroys the Canvas\n    #[inline]\n    pub fn into_surface(self) -> Surface<'s> {\n        self.target\n    }\n\n    /// Returns a `TextureCreator` that can create Textures to be drawn on this `Canvas`\n    ///\n    /// This `TextureCreator` will share a reference to the renderer and target context.\n    ///\n    /// The target (i.e., `Window`) will not be destroyed and the SDL_Renderer will not be\n    /// destroyed if the `TextureCreator` is still in scope.\n    pub fn texture_creator(&self) -> TextureCreator<SurfaceContext<'s>> {\n        TextureCreator {\n            context: self.context.clone(),\n            default_pixel_format: self.surface().pixel_format_enum(),\n        }\n    }\n}\n\npub type WindowCanvas = Canvas<Window>;\n\nimpl RenderTarget for Window {\n    type Context = WindowContext;\n}\n\n/// Methods for the `WindowCanvas`.\nimpl Canvas<Window> {\n    /// Gets a reference to the associated window of the Canvas\n    #[inline]\n    pub fn window(&self) -> &Window {\n        &self.target\n    }\n\n    /// Gets a mutable reference to the associated window of the Canvas\n    #[inline]\n    pub fn window_mut(&mut self) -> &mut Window {\n        &mut self.target\n    }\n\n    /// Gets the associated window of the Canvas and destroys the Canvas\n    #[inline]\n    pub fn into_window(self) -> Window {\n        self.target\n    }\n\n    /// Returns a `TextureCreator` that can create Textures to be drawn on this `Canvas`\n    ///\n    /// This `TextureCreator` will share a reference to the renderer and target context.\n    ///\n    /// The target (i.e., `Window`) will not be destroyed and the SDL_Renderer will not be\n    /// destroyed if the `TextureCreator` is still in scope.\n    pub fn texture_creator(&self) -> TextureCreator<WindowContext> {\n        TextureCreator {\n            context: self.context.clone(),\n            default_pixel_format: self.window().window_pixel_format(),\n        }\n    }\n}\n\nimpl<T: RenderTarget> Canvas<T> {\n    /// Determine whether a window supports the use of render targets.\n    pub fn render_target_supported(&self) -> bool {\n        unsafe { ll::SDL_RenderTargetSupported(self.context.raw) == 1 }\n    }\n\n    /// Temporarily sets the target of `Canvas` to a `Texture`. This effectively allows rendering\n    /// to a `Texture` in any way you want: you can make a `Texture` a combination of other\n    /// `Texture`s, be a complex geometry form with the `gfx` module, ... You can draw pixel by\n    /// pixel in it if you want, so you can do basically anything with that `Texture`.\n    ///\n    /// If you want to set the content of multiple `Texture` at once the most efficient way\n    /// possible, *don't* make a loop and call this function everytime and use\n    /// `with_multiple_texture_canvas` instead. Using `with_texture_canvas` is actually\n    /// inefficient because the target is reset to the source (the `Window` or the `Surface`)\n    /// at the end of this function, but using it in a loop would make this reset useless.\n    /// Plus, the check that render_target is actually supported on that `Canvas` is also\n    /// done every time, leading to useless checks.\n    ///\n    /// # Notes\n    ///\n    /// Note that the `Canvas` in the closure is exactly the same as the one you call this\n    /// function with, meaning that you can call every function of your original `Canvas`.\n    /// \n    /// That means you can also call `with_texture_canvas` and `with_multiple_texture_canvas` from\n    /// the inside of the closure. Even though this is useless and inefficient, this is totally\n    /// safe to do and allowed.\n    ///\n    /// Since the render target is now a Texture, some calls of Canvas might return another result\n    /// than if the target was to be the original source. For instance `output_size` will return\n    /// this size of the current `Texture` in the closure, but the size of the `Window` or\n    /// `Surface` outside of the closure.\n    ///\n    /// You do not need to call `present` after drawing in the Canvas in the closure, the changes\n    /// are appleid directly to the `Texture` instead of a hidden buffer.\n    ///\n    /// # Errors\n    ///\n    /// * returns `TargetRenderError::NotSupported`\n    /// if the renderer does not support the use of render targets\n    /// * returns `TargetRenderError::SdlError` if SDL2 returned with an error code.\n    ///\n    /// The texture *must* be created with the texture access:\n    /// `sdl2::render::TextureAccess::Target`.\n    /// Using a texture which was not created with the texture access `Target` is undefined\n    /// behavior.\n    ///\n    /// # Examples\n    ///\n    /// The example below changes a newly created `Texture` to be a 150-by-150 black texture with a\n    /// 50-by-50 red square in the middle.\n    ///\n    /// ```rust,no_run\n    /// # use sdl2::render::{Canvas, Texture};\n    /// # use sdl2::video::Window;\n    /// # use sdl2::pixels::Color;\n    /// # use sdl2::rect::Rect;\n    /// # let mut canvas : Canvas<Window> = unimplemented!();\n    /// let texture_creator = canvas.texture_creator();\n    /// let mut texture = texture_creator\n    ///     .create_texture_target(texture_creator.default_pixel_format(), 150, 150)\n    ///     .unwrap();\n    /// let result = canvas.with_texture_canvas(&mut texture, |texture_canvas| {\n    ///     texture_canvas.set_draw_color(Color::RGBA(0, 0, 0, 255));\n    ///     texture_canvas.clear();\n    ///     texture_canvas.set_draw_color(Color::RGBA(255, 0, 0, 255));\n    ///     texture_canvas.fill_rect(Rect::new(50, 50, 50, 50)).unwrap();\n    /// });\n    /// ```\n    ///\n    \n    pub fn with_texture_canvas<F>(&mut self, texture: &mut Texture, mut f: F)\n        -> Result<(), TargetRenderError> where for<'r> F: FnMut(&'r mut Canvas<T>,) {\n        if self.render_target_supported() {\n            unsafe { self.set_raw_target(texture.raw) }\n                .map_err(|e| TargetRenderError::SdlError(e))?;\n            f(self);\n            unsafe { self.set_raw_target(ptr::null_mut()) }\n                .map_err(|e| TargetRenderError::SdlError(e))?;\n            Ok(())\n        } else {\n            Err(TargetRenderError::NotSupported)\n        }\n    }\n\n    /// Same as `with_texture_canvas`, but allows to change multiple `Texture`s at once with the\n    /// least amount of overhead. It means that between every iteration the Target is not reset to\n    /// the source, and that the fact that the Canvas supports render target isn't checked every\n    /// iteration either; the check is actually only done once, at the beginning, avoiding useless\n    /// checks.\n    ///\n    /// The closure is run once for every `Texture` sent as parameter.\n    ///\n    /// The main changes from `with_texture_canvas` is that is takes an `Iterator` of `(&mut\n    /// Texture, U)`, where U is a type defined by the user. The closure takes a `&mut Canvas`, and\n    /// `&U` as arguments instead of a simple `&mut Canvas`. This user-defined type allows you to\n    /// keep track of what to do with the Canvas you have received in the closure.\n    ///\n    /// You will usually want to keep track of the number, a property, or anything that will allow\n    /// you to uniquely track this `Texture`, but it can also be an empty struct or `()` as well!\n    ///\n    /// # Examples\n    ///\n    /// Let's create two textures, one which will be yellow, and the other will be white\n    ///\n    /// ```rust,no_run\n    /// # use sdl2::pixels::Color;\n    /// # use sdl2::rect::Rect;\n    /// # use sdl2::video::Window;\n    /// # use sdl2::render::{Canvas, Texture};\n    /// # let mut canvas : Canvas<Window> = unimplemented!();\n    /// let texture_creator = canvas.texture_creator();\n    /// enum TextureColor {\n    ///     Yellow,\n    ///     White,\n    /// };\n    ///\n    /// let mut square_texture1 : Texture =\n    ///     texture_creator.create_texture_target(None, 100, 100).unwrap();\n    /// let mut square_texture2 : Texture =\n    ///     texture_creator.create_texture_target(None, 100, 100).unwrap();\n    /// let textures : Vec<(&mut Texture, TextureColor)> = vec![\n    ///     (&mut square_texture1, TextureColor::Yellow),\n    ///     (&mut square_texture2, TextureColor::White)\n    /// ];\n    /// let result : Result<(), _> =\n    ///     canvas.with_multiple_texture_canvas(textures.iter(), |texture_canvas, user_context| {\n    ///     match *user_context {\n    ///         TextureColor::White => {\n    ///             texture_canvas.set_draw_color(Color::RGB(255, 255, 255));\n    ///         },\n    ///         TextureColor::Yellow => {\n    ///             texture_canvas.set_draw_color(Color::RGB(255, 255, 0));\n    ///         }\n    ///     };\n    ///     texture_canvas.clear();\n    /// });\n    /// // square_texture1 is now Yellow and square_texture2 is now White!\n    /// ```\n    ///\n    ///\n    pub fn with_multiple_texture_canvas<'t : 'a, 'a : 's, 's, I, F, U: 's>(&mut self, textures: I, mut f: F)\n        -> Result<(), TargetRenderError>\n        where for<'r> F: FnMut(&'r mut Canvas<T>, &U), I: Iterator<Item=&'s (&'a mut Texture<'t>, U)> {\n        if self.render_target_supported() {\n            for &(ref texture, ref user_context) in textures {\n                unsafe { self.set_raw_target(texture.raw) }\n                    .map_err(|e| TargetRenderError::SdlError(e))?;\n                f(self, &user_context);\n            }\n            // reset the target to its source\n            unsafe { self.set_raw_target(ptr::null_mut()) }\n                .map_err(|e| TargetRenderError::SdlError(e))?;\n            Ok(())\n        } else {\n            Err(TargetRenderError::NotSupported)\n        }\n    }\n}\n\n/// Creates Textures that cannot outlive the creator\n///\n/// The `TextureCreator` does not hold a lifetime to its Canvas by design choice.\n///\n/// If a `Canvas` is dropped before its `TextureCreator`, it is still safe to use.\n/// \n/// It is, however, useless.\n///\n/// Any `Texture` created here can only be drawn onto the original `Canvas`. A `Texture` used in a\n/// `Canvas` must come from a `TextureCreator` coming from that same `Canvas`. Using a `Texture` to\n/// render to a `Canvas` not being the parent of the `Texture`'s `TextureCreator` is undefined\n/// behavior. \npub struct TextureCreator<T> {\n    context: Rc<RendererContext<T>>,\n    default_pixel_format: PixelFormatEnum,\n}\n\n/// The type that allows you to build Window-based renderers.\n///\n/// By default, the renderer builder will prioritize for a hardware-accelerated\n/// renderer, which is porbably what you want.\npub struct CanvasBuilder {\n    window: Window,\n    index: Option<u32>,\n    renderer_flags: u32,\n}\n\nimpl CanvasBuilder {\n    /// Initializes a new `CanvasBuilder`.\n    pub fn new(window: Window) -> CanvasBuilder {\n        CanvasBuilder {\n            window: window,\n            // -1 means to initialize the first rendering driver supporting the\n            // renderer flags\n            index: None,\n            // no flags gives priority to available SDL_RENDERER_ACCELERATED\n            // renderers\n            renderer_flags: 0,\n        }\n    }\n\n    /// Builds the renderer.\n    pub fn build(self) -> Result<WindowCanvas, IntegerOrSdlError> {\n        use common::IntegerOrSdlError::*;\n        let index = match self.index {\n            None => -1,\n            Some(index) => try!(validate_int(index, \"index\")),\n        };\n        let raw = unsafe { ll::SDL_CreateRenderer(self.window.raw(), index, self.renderer_flags) };\n\n        if raw.is_null() {\n            Err(SdlError(get_error()))\n        } else {\n            let context = Rc::new(unsafe { RendererContext::from_ll(raw, self.window.context()) });\n            Ok(Canvas {\n                   context: context,\n                   target: self.window,\n               })\n        }\n    }\n\n    /// Sets the index of the rendering driver to initialize.\n    /// If you desire the first rendering driver to support the flags provided,\n    /// or if you're translating code from C which passes -1 for the index,\n    /// **do not** invoke the `index` method.\n    pub fn index(mut self, index: u32) -> CanvasBuilder {\n        self.index = Some(index);\n        self\n    }\n\n    /// Set the renderer to a software fallback.\n    /// This flag is accumulative, and may be specified with other flags.\n    pub fn software(mut self) -> CanvasBuilder {\n        self.renderer_flags |= ll::SDL_RENDERER_SOFTWARE as u32;\n        self\n    }\n\n    /// Set the renderer to use hardware acceleration.\n    /// This flag is accumulative, and may be specified with other flags.\n    pub fn accelerated(mut self) -> CanvasBuilder {\n        self.renderer_flags |= ll::SDL_RENDERER_ACCELERATED as u32;\n        self\n    }\n\n    /// Synchronize renderer `present` method calls with the refresh rate.\n    /// This flag is accumulative, and may be specified with other flags.\n    pub fn present_vsync(mut self) -> CanvasBuilder {\n        self.renderer_flags |= ll::SDL_RENDERER_PRESENTVSYNC as u32;\n        self\n    }\n\n    /// Set the renderer to support rendering to a texture.\n    /// This flag is accumulative, and may be specified with other flags.\n    pub fn target_texture(mut self) -> CanvasBuilder {\n        self.renderer_flags |= ll::SDL_RENDERER_TARGETTEXTURE as u32;\n        self\n    }\n}\n\n#[derive(Debug)]\npub enum TextureValueError {\n    WidthOverflows(u32),\n    HeightOverflows(u32),\n    WidthMustBeMultipleOfTwoForFormat(u32, PixelFormatEnum),\n    SdlError(String),\n}\n\nimpl fmt::Display for TextureValueError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::TextureValueError::*;\n\n        match *self {\n            WidthOverflows(value) => write!(f, \"Integer width overflows ({})\", value),\n            HeightOverflows(value) => write!(f, \"Integer height overflows ({})\", value),\n            WidthMustBeMultipleOfTwoForFormat(value, format) => {\n                write!(f,\n                       \"Texture width must be multiple of two for pixel format '{:?}' ({})\",\n                       format,\n                       value)\n            }\n            SdlError(ref e) => write!(f, \"SDL error: {}\", e),\n        }\n    }\n}\n\nimpl Error for TextureValueError {\n    fn description(&self) -> &str {\n        use self::TextureValueError::*;\n\n        match *self {\n            WidthOverflows(_) => \"texture width overflow\",\n            HeightOverflows(_) => \"texture height overflow\",\n            WidthMustBeMultipleOfTwoForFormat(..) => \"texture width must be multiple of two\",\n            SdlError(ref e) => e,\n        }\n    }\n}\n\n/// Texture-creating methods for the renderer\nimpl<T> TextureCreator<T> {\n    pub fn raw(&self) -> *mut ll::SDL_Renderer {\n        self.context.raw()\n    }\n\n    pub fn default_pixel_format(&self) -> PixelFormatEnum {\n        self.default_pixel_format.clone()\n    }\n\n    /// Creates a texture for a rendering context.\n    ///\n    /// If format is `None`, the format will be the one the parent Window or Surface uses.\n    ///\n    /// If format is `Some(pixel_format)` the default will be overridden and the texture will be\n    /// created with the specified format if possible. If the PixelFormat is not supported, this\n    /// will return an error.\n    ///\n    /// You should prefer the default format if possible to have performance gains and to avoid\n    /// unsupported Pixel Formats that can cause errors. However, be careful with the default\n    /// `PixelFormat` if you want to create transparent textures.\n    pub fn create_texture<F>(&self,\n                             format: F,\n                             access: TextureAccess,\n                             width: u32,\n                             height: u32)\n                             -> Result<Texture, TextureValueError>\n        where F: Into<Option<PixelFormatEnum>>\n    {\n        use self::TextureValueError::*;\n        let w = match validate_int(width, \"width\") {\n            Ok(w) => w,\n            Err(_) => return Err(WidthOverflows(width)),\n        };\n        let h = match validate_int(height, \"height\") {\n            Ok(h) => h,\n            Err(_) => return Err(HeightOverflows(height)),\n        };\n        let format: PixelFormatEnum = format.into().unwrap_or(self.default_pixel_format);\n\n        // If the pixel format is YUV 4:2:0 and planar, the width and height must\n        // be multiples-of-two. See issue #334 for details.\n        match format {\n            PixelFormatEnum::YV12 |\n            PixelFormatEnum::IYUV => {\n                if w % 2 != 0 || h % 2 != 0 {\n                    return Err(WidthMustBeMultipleOfTwoForFormat(width, format));\n                }\n            }\n            _ => (),\n        }\n\n        let result = unsafe {\n            ll::SDL_CreateTexture(self.context.raw, format as uint32_t, access as c_int, w, h)\n        };\n        if result.is_null() {\n            Err(SdlError(get_error()))\n        } else {\n            unsafe { Ok(self.raw_create_texture(result)) }\n        }\n    }\n\n    /// Shorthand for `create_texture(format, TextureAccess::Static, width, height)`\n    pub fn create_texture_static<F>(&self,\n                                    format: F,\n                                    width: u32,\n                                    height: u32)\n                                    -> Result<Texture, TextureValueError>\n        where F: Into<Option<PixelFormatEnum>>\n    {\n        self.create_texture(format, TextureAccess::Static, width, height)\n    }\n\n    /// Shorthand for `create_texture(format, TextureAccess::Streaming, width, height)`\n    pub fn create_texture_streaming<F>(&self,\n                                       format: F,\n                                       width: u32,\n                                       height: u32)\n                                       -> Result<Texture, TextureValueError>\n        where F: Into<Option<PixelFormatEnum>>\n    {\n        self.create_texture(format, TextureAccess::Streaming, width, height)\n    }\n\n    /// Shorthand for `create_texture(format, TextureAccess::Target, width, height)`\n    pub fn create_texture_target<F>(&self,\n                                    format: F,\n                                    width: u32,\n                                    height: u32)\n                                    -> Result<Texture, TextureValueError>\n        where F: Into<Option<PixelFormatEnum>>\n    {\n        self.create_texture(format, TextureAccess::Target, width, height)\n    }\n\n    /// Creates a texture from an existing surface.\n    /// # Remarks\n    /// The access hint for the created texture is `TextureAccess::Static`.\n    pub fn create_texture_from_surface<S: AsRef<SurfaceRef>>\n        (&self,\n         surface: S)\n         -> Result<Texture, TextureValueError> {\n        use self::TextureValueError::*;\n        let result =\n            unsafe { ll::SDL_CreateTextureFromSurface(self.context.raw, surface.as_ref().raw()) };\n        if result.is_null() {\n            Err(SdlError(get_error()))\n        } else {\n            unsafe { Ok(self.raw_create_texture(result)) }\n        }\n    }\n\n    pub unsafe fn raw_create_texture(&self, raw: *mut ll::SDL_Texture) -> Texture {\n        Texture {\n            raw: raw,\n            _marker: PhantomData,\n        }\n    }\n}\n\n// pub struct TextureTarget<'r, 't, TC> {\n//     raw_renderer: &'r *mut ll::SDL_Renderer,\n//     _texture_marker: PhantomData<&'t ()>,\n//     // unfortunately there is no way to know which kind of Renderer we have here at compile time,\n//     // so this PhantomData is here to keep track of that.\n//     _texture_target: PhantomData<TC>,\n// }\n\n/// Drawing methods\nimpl<T: RenderTarget> Canvas<T> {\n    pub fn raw(&self) -> *mut ll::SDL_Renderer {\n        self.context.raw()\n    }\n\n    /// Sets the color used for drawing operations (Rect, Line and Clear).\n    pub fn set_draw_color(&mut self, color: pixels::Color) {\n        let (r, g, b, a) = color.rgba();\n        let ret = unsafe { ll::SDL_SetRenderDrawColor(self.raw, r, g, b, a) };\n        // Should only fail on an invalid renderer\n        if ret != 0 {\n            panic!(get_error())\n        }\n    }\n\n    /// Gets the color used for drawing operations (Rect, Line and Clear).\n    pub fn draw_color(&self) -> pixels::Color {\n        let (mut r, mut g, mut b, mut a) = (0, 0, 0, 0);\n        let ret =\n            unsafe { ll::SDL_GetRenderDrawColor(self.context.raw, &mut r, &mut g, &mut b, &mut a) };\n        // Should only fail on an invalid renderer\n        if ret != 0 {\n            panic!(get_error())\n        } else {\n            pixels::Color::RGBA(r, g, b, a)\n        }\n    }\n\n    /// Sets the blend mode used for drawing operations (Fill and Line).\n    pub fn set_blend_mode(&mut self, blend: BlendMode) {\n        let ret = unsafe {\n            ll::SDL_SetRenderDrawBlendMode(self.context.raw,\n                                           FromPrimitive::from_i64(blend as i64).unwrap())\n        };\n        // Should only fail on an invalid renderer\n        if ret != 0 {\n            panic!(get_error())\n        }\n    }\n\n    /// Gets the blend mode used for drawing operations.\n    pub fn blend_mode(&self) -> BlendMode {\n        let mut blend = 0;\n        let ret = unsafe { ll::SDL_GetRenderDrawBlendMode(self.context.raw, &mut blend) };\n        // Should only fail on an invalid renderer\n        if ret != 0 {\n            panic!(get_error())\n        } else {\n            FromPrimitive::from_i64(blend as i64).unwrap()\n        }\n    }\n\n    /// Clears the current rendering target with the drawing color.\n    pub fn clear(&mut self) {\n        let ret = unsafe { ll::SDL_RenderClear(self.context.raw) };\n        if ret != 0 {\n            panic!(\"Could not clear: {}\", get_error())\n        }\n    }\n\n    /// Updates the screen with any rendering performed since the previous call.\n    ///\n    /// SDL's rendering functions operate on a backbuffer; that is, calling a\n    /// rendering function such as `draw_line()` does not directly put a line on\n    /// the screen, but rather updates the backbuffer.\n    /// As such, you compose your entire scene and present the composed\n    /// backbuffer to the screen as a complete picture.\n    pub fn present(&mut self) {\n        unsafe { ll::SDL_RenderPresent(self.context.raw) }\n    }\n\n    /// Gets the output size of a rendering context.\n    pub fn output_size(&self) -> Result<(u32, u32), String> {\n        let mut width = 0;\n        let mut height = 0;\n\n        let result =\n            unsafe { ll::SDL_GetRendererOutputSize(self.context.raw, &mut width, &mut height) };\n\n        if result == 0 {\n            Ok((width as u32, height as u32))\n        } else {\n            Err(get_error())\n        }\n    }\n\n    /// Sets a device independent resolution for rendering.\n    pub fn set_logical_size(&mut self, width: u32, height: u32) -> Result<(), IntegerOrSdlError> {\n        use common::IntegerOrSdlError::*;\n        let width = try!(validate_int(width, \"width\"));\n        let height = try!(validate_int(height, \"height\"));\n        let result = unsafe { ll::SDL_RenderSetLogicalSize(self.context.raw, width, height) };\n        match result {\n            0 => Ok(()),\n            _ => Err(SdlError(get_error())),\n        }\n    }\n\n    /// Gets device independent resolution for rendering.\n    pub fn logical_size(&self) -> (u32, u32) {\n        let mut width = 0;\n        let mut height = 0;\n\n        unsafe { ll::SDL_RenderGetLogicalSize(self.context.raw, &mut width, &mut height) };\n\n        (width as u32, height as u32)\n    }\n\n    /// Sets the drawing area for rendering on the current target.\n    pub fn set_viewport<R: Into<Option<Rect>>>(&mut self, rect: R) {\n        let ptr = match rect.into() {\n            Some(ref rect) => rect.raw(),\n            None => ptr::null(),\n        };\n        let ret = unsafe { ll::SDL_RenderSetViewport(self.context.raw, ptr) };\n        if ret != 0 {\n            panic!(\"Could not set viewport: {}\", get_error())\n        }\n    }\n\n    /// Gets the drawing area for the current target.\n    pub fn viewport(&self) -> Rect {\n        let mut rect = unsafe { mem::uninitialized() };\n        unsafe { ll::SDL_RenderGetViewport(self.context.raw, &mut rect) };\n        Rect::from_ll(rect)\n    }\n\n    /// Sets the clip rectangle for rendering on the specified target.\n    ///\n    /// If the rectangle is `None`, clipping will be disabled.\n    pub fn set_clip_rect<R: Into<Option<Rect>>>(&mut self, rect: R) {\n        let ret = unsafe {\n            ll::SDL_RenderSetClipRect(self.context.raw,\n                                      match rect.into() {\n                                          Some(ref rect) => rect.raw(),\n                                          None => ptr::null(),\n                                      })\n        };\n        if ret != 0 {\n            panic!(\"Could not set clip rect: {}\", get_error())\n        }\n    }\n\n    /// Gets the clip rectangle for the current target.\n    ///\n    /// Returns `None` if clipping is disabled.\n    pub fn clip_rect(&self) -> Option<Rect> {\n        let mut raw = unsafe { mem::uninitialized() };\n        unsafe { ll::SDL_RenderGetClipRect(self.context.raw, &mut raw) };\n        if raw.w == 0 || raw.h == 0 {\n            None\n        } else {\n            Some(Rect::from_ll(raw))\n        }\n    }\n\n    /// Sets the drawing scale for rendering on the current target.\n    pub fn set_scale(&mut self, scale_x: f32, scale_y: f32) -> Result<(), String> {\n        let ret = unsafe { ll::SDL_RenderSetScale(self.context.raw, scale_x, scale_y) };\n        // Should only fail on an invalid renderer\n        if ret != 0 { Err(get_error()) } else { Ok(()) }\n    }\n\n    /// Gets the drawing scale for the current target.\n    pub fn scale(&self) -> (f32, f32) {\n        let mut scale_x = 0.0;\n        let mut scale_y = 0.0;\n        unsafe { ll::SDL_RenderGetScale(self.context.raw, &mut scale_x, &mut scale_y) };\n        (scale_x, scale_y)\n    }\n\n    /// Draws a point on the current rendering target.\n    /// Errors if drawing fails for any reason (e.g. driver failure)\n    pub fn draw_point<P: Into<Point>>(&mut self, point: P) -> Result<(), String> {\n        let point = point.into();\n        let result = unsafe { ll::SDL_RenderDrawPoint(self.context.raw, point.x(), point.y()) };\n        if result != 0 {\n            Err(get_error())\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Draws multiple points on the current rendering target.\n    /// Errors if drawing fails for any reason (e.g. driver failure)\n    pub fn draw_points<'a, P: Into<&'a [Point]>>(&mut self, points: P) -> Result<(), String> {\n        let points = points.into();\n        let result = unsafe {\n            ll::SDL_RenderDrawPoints(self.context.raw,\n                                     Point::raw_slice(points),\n                                     points.len() as c_int)\n        };\n        if result != 0 {\n            Err(get_error())\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Draws a line on the current rendering target.\n    /// Errors if drawing fails for any reason (e.g. driver failure)\n    pub fn draw_line<P1: Into<Point>, P2: Into<Point>>(&mut self,\n                                                       start: P1,\n                                                       end: P2)\n                                                       -> Result<(), String> {\n        let start = start.into();\n        let end = end.into();\n        let result = unsafe {\n            ll::SDL_RenderDrawLine(self.context.raw, start.x(), start.y(), end.x(), end.y())\n        };\n        if result != 0 {\n            Err(get_error())\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Draws a series of connected lines on the current rendering target.\n    /// Errors if drawing fails for any reason (e.g. driver failure)\n    pub fn draw_lines<'a, P: Into<&'a [Point]>>(&mut self, points: P) -> Result<(), String> {\n        let points = points.into();\n        let result = unsafe {\n            ll::SDL_RenderDrawLines(self.context.raw,\n                                    Point::raw_slice(points),\n                                    points.len() as c_int)\n        };\n        if result != 0 {\n            Err(get_error())\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Draws a rectangle on the current rendering target.\n    /// Errors if drawing fails for any reason (e.g. driver failure)\n    pub fn draw_rect(&mut self, rect: Rect) -> Result<(), String> {\n        let result = unsafe { ll::SDL_RenderDrawRect(self.context.raw, rect.raw()) };\n        if result != 0 {\n            Err(get_error())\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Draws some number of rectangles on the current rendering target.\n    /// Errors if drawing fails for any reason (e.g. driver failure)\n    pub fn draw_rects(&mut self, rects: &[Rect]) -> Result<(), String> {\n        let result = unsafe {\n            ll::SDL_RenderDrawRects(self.context.raw,\n                                    Rect::raw_slice(rects),\n                                    rects.len() as c_int)\n        };\n        if result != 0 {\n            Err(get_error())\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Fills a rectangle on the current rendering target with the drawing\n    /// color.\n    /// Passing None will fill the entire rendering target.\n    /// Errors if drawing fails for any reason (e.g. driver failure)\n    pub fn fill_rect<R: Into<Option<Rect>>>(&mut self, rect: R) -> Result<(), String> {\n        let result = unsafe {\n            ll::SDL_RenderFillRect(self.context.raw,\n                                   rect.into()\n                                       .as_ref()\n                                       .map(|r| r.raw())\n                                       .unwrap_or(ptr::null()))\n        };\n        if result != 0 {\n            Err(get_error())\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Fills some number of rectangles on the current rendering target with\n    /// the drawing color.\n    /// Errors if drawing fails for any reason (e.g. driver failure)\n    pub fn fill_rects(&mut self, rects: &[Rect]) -> Result<(), String> {\n        let result = unsafe {\n            ll::SDL_RenderFillRects(self.context.raw,\n                                    Rect::raw_slice(rects),\n                                    rects.len() as c_int)\n        };\n        if result != 0 {\n            Err(get_error())\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Copies a portion of the texture to the current rendering target.\n    ///\n    /// * If `src` is `None`, the entire texture is copied.\n    /// * If `dst` is `None`, the texture will be stretched to fill the given\n    ///   rectangle.\n    ///\n    /// Errors if drawing fails for any reason (e.g. driver failure),\n    /// or if the provided texture does not belong to the renderer.\n    pub fn copy<R1, R2>(&mut self, texture: &Texture, src: R1, dst: R2) -> Result<(), String>\n        where R1: Into<Option<Rect>>,\n              R2: Into<Option<Rect>>\n    {\n        let ret = unsafe {\n            ll::SDL_RenderCopy(self.context.raw,\n                               texture.raw,\n                               match src.into() {\n                                   Some(ref rect) => rect.raw(),\n                                   None => ptr::null(),\n                               },\n                               match dst.into() {\n                                   Some(ref rect) => rect.raw(),\n                                   None => ptr::null(),\n                               })\n        };\n\n        if ret != 0 { Err(get_error()) } else { Ok(()) }\n    }\n\n    /// Copies a portion of the texture to the current rendering target,\n    /// optionally rotating it by angle around the given center and also\n    /// flipping it top-bottom and/or left-right.\n    ///\n    /// * If `src` is `None`, the entire texture is copied.\n    /// * If `dst` is `None`, the texture will be stretched to fill the given\n    ///   rectangle.\n    /// * If `center` is `None`, rotation will be done around the center point\n    ///   of `dst`, or `src` if `dst` is None.\n    ///\n    /// Errors if drawing fails for any reason (e.g. driver failure),\n    /// if the provided texture does not belong to the renderer,\n    /// or if the driver does not support RenderCopyEx.\n    pub fn copy_ex<R1, R2, P>(&mut self,\n                              texture: &Texture,\n                              src: R1,\n                              dst: R2,\n                              angle: f64,\n                              center: P,\n                              flip_horizontal: bool,\n                              flip_vertical: bool)\n                              -> Result<(), String>\n        where R1: Into<Option<Rect>>,\n              R2: Into<Option<Rect>>,\n              P: Into<Option<Point>>\n    {\n        let flip = match (flip_horizontal, flip_vertical) {\n            (false, false) => ll::SDL_FLIP_NONE,\n            (true, false) => ll::SDL_FLIP_HORIZONTAL,\n            (false, true) => ll::SDL_FLIP_VERTICAL,\n            (true, true) => ll::SDL_FLIP_HORIZONTAL | ll::SDL_FLIP_VERTICAL,\n        };\n\n        let ret = unsafe {\n            ll::SDL_RenderCopyEx(self.context.raw,\n                                 texture.raw,\n                                 match src.into() {\n                                     Some(ref rect) => rect.raw(),\n                                     None => ptr::null(),\n                                 },\n                                 match dst.into() {\n                                     Some(ref rect) => rect.raw(),\n                                     None => ptr::null(),\n                                 },\n                                 angle as c_double,\n                                 match center.into() {\n                                     Some(ref point) => point.raw(),\n                                     None => ptr::null(),\n                                 },\n                                 flip)\n        };\n\n        if ret != 0 { Err(get_error()) } else { Ok(()) }\n    }\n\n    /// Reads pixels from the current rendering target.\n    /// # Remarks\n    /// WARNING: This is a very slow operation, and should not be used frequently.\n    pub fn read_pixels<R: Into<Option<Rect>>>(&self,\n                                              rect: R,\n                                              format: pixels::PixelFormatEnum)\n                                              -> Result<Vec<u8>, String> {\n        unsafe {\n            let rect = rect.into();\n            let (actual_rect, w, h) = match rect {\n                Some(ref rect) => (rect.raw(), rect.width() as usize, rect.height() as usize),\n                None => {\n                    let (w, h) = try!(self.output_size());\n                    (ptr::null(), w as usize, h as usize)\n                }\n            };\n\n            let pitch = w * format.byte_size_per_pixel(); // calculated pitch\n            let size = format.byte_size_of_pixels(w * h);\n            let mut pixels = Vec::with_capacity(size);\n            pixels.set_len(size);\n\n            // Pass the interior of `pixels: Vec<u8>` to SDL\n            let ret = {\n                ll::SDL_RenderReadPixels(self.context.raw,\n                                         actual_rect,\n                                         format as uint32_t,\n                                         pixels.as_mut_ptr() as *mut c_void,\n                                         pitch as c_int)\n            };\n\n            if ret == 0 {\n                Ok(pixels)\n            } else {\n                Err(get_error())\n            }\n        }\n    }\n}\n\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\npub struct TextureQuery {\n    pub format: pixels::PixelFormatEnum,\n    pub access: TextureAccess,\n    pub width: u32,\n    pub height: u32,\n}\n\n/// A texture for a rendering context.\n///\n/// Every Texture is owned by a `TextureCreator`.\n/// A `Texture` cannot outlive the `TextureCreator`\n///\n/// A `Texture` can be safely accessed after the `Canvas` is dropped.\npub struct Texture<'r> {\n    raw: *mut ll::SDL_Texture,\n    _marker: PhantomData<&'r ()>,\n}\n\nimpl<'r> Drop for Texture<'r> {\n    fn drop(&mut self) {\n        unsafe {\n            ll::SDL_DestroyTexture(self.raw);\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum UpdateTextureError {\n    PitchOverflows(usize),\n    PitchMustBeMultipleOfTwoForFormat(usize, PixelFormatEnum),\n    XMustBeMultipleOfTwoForFormat(i32, PixelFormatEnum),\n    YMustBeMultipleOfTwoForFormat(i32, PixelFormatEnum),\n    WidthMustBeMultipleOfTwoForFormat(u32, PixelFormatEnum),\n    HeightMustBeMultipleOfTwoForFormat(u32, PixelFormatEnum),\n    SdlError(String),\n}\n\nimpl fmt::Display for UpdateTextureError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::UpdateTextureError::*;\n\n        match *self {\n            PitchOverflows(value) => write!(f, \"Pitch overflows ({})\", value),\n            PitchMustBeMultipleOfTwoForFormat(value, format) => {\n                write!(f,\n                       \"Pitch must be multiple of two for pixel format '{:?}' ({})\",\n                       format,\n                       value)\n            }\n            XMustBeMultipleOfTwoForFormat(value, format) => {\n                write!(f,\n                       \"X must be multiple of two for pixel format '{:?}' ({})\",\n                       format,\n                       value)\n            }\n            YMustBeMultipleOfTwoForFormat(value, format) => {\n                write!(f,\n                       \"Y must be multiple of two for pixel format '{:?}' ({})\",\n                       format,\n                       value)\n            }\n            WidthMustBeMultipleOfTwoForFormat(value, format) => {\n                write!(f,\n                       \"Width must be multiple of two for pixel format '{:?}' ({})\",\n                       format,\n                       value)\n            }\n            HeightMustBeMultipleOfTwoForFormat(value, format) => {\n                write!(f,\n                       \"Height must be multiple of two for pixel format '{:?}' ({})\",\n                       format,\n                       value)\n            }\n            SdlError(ref e) => write!(f, \"SDL error: {}\", e),\n        }\n    }\n}\n\nimpl Error for UpdateTextureError {\n    fn description(&self) -> &str {\n        use self::UpdateTextureError::*;\n\n        match *self {\n            PitchOverflows(_) => \"pitch overflow\",\n            PitchMustBeMultipleOfTwoForFormat(..) => \"pitch must be multiple of two\",\n            XMustBeMultipleOfTwoForFormat(..) => \"x must be multiple of two\",\n            YMustBeMultipleOfTwoForFormat(..) => \"y must be multiple of two\",\n            WidthMustBeMultipleOfTwoForFormat(..) => \"width must be multiple of two\",\n            HeightMustBeMultipleOfTwoForFormat(..) => \"height must be multiple of two\",\n            SdlError(ref e) => e,\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum UpdateTextureYUVError {\n    PitchOverflows { plane: &'static str, value: usize },\n    InvalidPlaneLength {\n        plane: &'static str,\n        length: usize,\n        pitch: usize,\n        height: usize,\n    },\n    XMustBeMultipleOfTwoForFormat(i32),\n    YMustBeMultipleOfTwoForFormat(i32),\n    WidthMustBeMultipleOfTwoForFormat(u32),\n    HeightMustBeMultipleOfTwoForFormat(u32),\n    RectNotInsideTexture(Rect),\n    SdlError(String),\n}\n\nimpl fmt::Display for UpdateTextureYUVError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::UpdateTextureYUVError::*;\n\n        match *self {\n            PitchOverflows { plane, value } => {\n                write!(f, \"Pitch overflows on {} plane ({})\", plane, value)\n            }\n            InvalidPlaneLength {\n                plane,\n                length,\n                pitch,\n                height,\n            } => {\n                write!(f,\n                       \"The {} plane is wrong length ({}, should be {} * {})\",\n                       plane,\n                       length,\n                       pitch,\n                       height)\n            }\n            XMustBeMultipleOfTwoForFormat(value) => {\n                write!(f, \"X must be multiple of two ({})\", value)\n            }\n            YMustBeMultipleOfTwoForFormat(value) => {\n                write!(f, \"Y must be multiple of two ({})\", value)\n            }\n            WidthMustBeMultipleOfTwoForFormat(value) => {\n                write!(f, \"Width must be multiple of two ({})\", value)\n            }\n            HeightMustBeMultipleOfTwoForFormat(value) => {\n                write!(f, \"Height must be multiple of two ({})\", value)\n            }\n            RectNotInsideTexture(_) => write!(f, \"Rect must be inside texture\"),\n            SdlError(ref e) => write!(f, \"SDL error: {}\", e),\n        }\n    }\n}\n\nimpl Error for UpdateTextureYUVError {\n    fn description(&self) -> &str {\n        use self::UpdateTextureYUVError::*;\n\n        match *self {\n            PitchOverflows { .. } => \"pitch overflow\",\n            InvalidPlaneLength { .. } => \"invalid plane length\",\n            XMustBeMultipleOfTwoForFormat(_) => \"x must be multiple of two\",\n            YMustBeMultipleOfTwoForFormat(_) => \"y must be multiple of two\",\n            WidthMustBeMultipleOfTwoForFormat(_) => \"width must be multiple of two\",\n            HeightMustBeMultipleOfTwoForFormat(_) => \"height must be multiple of two\",\n            RectNotInsideTexture(_) => \"rect must be inside texture\",\n            SdlError(ref e) => e,\n        }\n    }\n}\n\nimpl<'r> Texture<'r> {\n    /// Queries the attributes of the texture.\n    pub fn query(&self) -> TextureQuery {\n        let mut format = 0;\n        let mut access = 0;\n        let mut width = 0;\n        let mut height = 0;\n\n        let ret = unsafe {\n            ll::SDL_QueryTexture(self.raw, &mut format, &mut access, &mut width, &mut height)\n        };\n        // Should only fail on an invalid texture\n        if ret != 0 {\n            panic!(get_error())\n        } else {\n            TextureQuery {\n                format: FromPrimitive::from_i64(format as i64).unwrap(),\n                access: FromPrimitive::from_i64(access as i64).unwrap(),\n                width: width as u32,\n                height: height as u32,\n            }\n        }\n    }\n\n    /// Sets an additional color value multiplied into render copy operations.\n    pub fn set_color_mod(&mut self, red: u8, green: u8, blue: u8) {\n        let ret = unsafe { ll::SDL_SetTextureColorMod(self.raw, red, green, blue) };\n\n        if ret != 0 {\n            panic!(\"Error setting color mod: {}\", get_error())\n        }\n    }\n\n    /// Gets the additional color value multiplied into render copy operations.\n    pub fn color_mod(&self) -> (u8, u8, u8) {\n        let (mut r, mut g, mut b) = (0, 0, 0);\n        let ret = unsafe { ll::SDL_GetTextureColorMod(self.raw, &mut r, &mut g, &mut b) };\n\n        // Should only fail on an invalid texture\n        if ret != 0 {\n            panic!(get_error())\n        } else {\n            (r, g, b)\n        }\n    }\n\n    /// Sets an additional alpha value multiplied into render copy operations.\n    pub fn set_alpha_mod(&mut self, alpha: u8) {\n        let ret = unsafe { ll::SDL_SetTextureAlphaMod(self.raw, alpha) };\n\n        if ret != 0 {\n            panic!(\"Error setting alpha mod: {}\", get_error())\n        }\n    }\n\n    /// Gets the additional alpha value multiplied into render copy operations.\n    pub fn alpha_mod(&self) -> u8 {\n        let mut alpha = 0;\n        let ret = unsafe { ll::SDL_GetTextureAlphaMod(self.raw, &mut alpha) };\n\n        // Should only fail on an invalid texture\n        if ret != 0 { panic!(get_error()) } else { alpha }\n    }\n\n    /// Sets the blend mode for a texture, used by `Renderer::copy()`.\n    pub fn set_blend_mode(&mut self, blend: BlendMode) {\n        let ret = unsafe {\n            ll::SDL_SetTextureBlendMode(self.raw, FromPrimitive::from_i64(blend as i64).unwrap())\n        };\n\n        if ret != 0 {\n            panic!(\"Error setting blend: {}\", get_error())\n        }\n    }\n\n    /// Gets the blend mode used for texture copy operations.\n    pub fn blend_mode(&self) -> BlendMode {\n        let mut blend = 0;\n        let ret = unsafe { ll::SDL_GetTextureBlendMode(self.raw, &mut blend) };\n\n        // Should only fail on an invalid texture\n        if ret != 0 {\n            panic!(get_error())\n        } else {\n            FromPrimitive::from_i64(blend as i64).unwrap()\n        }\n    }\n\n    /// Updates the given texture rectangle with new pixel data.\n    ///\n    /// `pitch` is the number of bytes in a row of pixel data, including padding\n    /// between lines\n    ///\n    /// * If `rect` is `None`, the entire texture is updated.\n    pub fn update<R>(&mut self,\n                     rect: R,\n                     pixel_data: &[u8],\n                     pitch: usize)\n                     -> Result<(), UpdateTextureError>\n        where R: Into<Option<Rect>>\n    {\n        use self::UpdateTextureError::*;\n        let rect = rect.into();\n        let rect_raw_ptr = match rect {\n            Some(ref rect) => rect.raw(),\n            None => ptr::null(),\n        };\n\n        // Check if the rectangle's position or size is odd, and if the pitch is odd.\n        // This needs to be done in case the texture's pixel format is planar YUV.\n        // See issue #334 for details.\n        let TextureQuery { format, .. } = self.query();\n        match format {\n            PixelFormatEnum::YV12 |\n            PixelFormatEnum::IYUV => {\n                match rect {\n                    Some(r) => {\n                        if r.x() % 2 != 0 {\n                            return Err(XMustBeMultipleOfTwoForFormat(r.x(), format));\n                        } else if r.y() % 2 != 0 {\n                            return Err(YMustBeMultipleOfTwoForFormat(r.y(), format));\n                        } else if r.width() % 2 != 0 {\n                            return Err(WidthMustBeMultipleOfTwoForFormat(r.width(), format));\n                        } else if r.height() % 2 != 0 {\n                            return Err(HeightMustBeMultipleOfTwoForFormat(r.height(), format));\n                        }\n                    }\n                    _ => {}\n                };\n                if pitch % 2 != 0 {\n                    return Err(PitchMustBeMultipleOfTwoForFormat(pitch, format));\n                }\n            }\n            _ => {}\n        }\n\n        let pitch = match validate_int(pitch as u32, \"pitch\") {\n            Ok(p) => p,\n            Err(_) => return Err(PitchOverflows(pitch)),\n        };\n\n        let result = unsafe {\n            ll::SDL_UpdateTexture(self.raw,\n                                  rect_raw_ptr,\n                                  pixel_data.as_ptr() as *const _,\n                                  pitch)\n        };\n\n        if result != 0 {\n            Err(SdlError(get_error()))\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Updates a rectangle within a planar YV12 or IYUV texture with new pixel data.\n    pub fn update_yuv<R>(&mut self,\n                         rect: R,\n                         y_plane: &[u8],\n                         y_pitch: usize,\n                         u_plane: &[u8],\n                         u_pitch: usize,\n                         v_plane: &[u8],\n                         v_pitch: usize)\n                         -> Result<(), UpdateTextureYUVError>\n        where R: Into<Option<Rect>>\n    {\n        use self::UpdateTextureYUVError::*;\n\n        let rect = rect.into();\n\n        let rect_raw_ptr = match rect {\n            Some(ref rect) => rect.raw(),\n            None => ptr::null(),\n        };\n\n        match rect {\n            Some(ref r) => {\n                if r.x() % 2 != 0 {\n                    return Err(XMustBeMultipleOfTwoForFormat(r.x()));\n                } else if r.y() % 2 != 0 {\n                    return Err(YMustBeMultipleOfTwoForFormat(r.y()));\n                } else if r.width() % 2 != 0 {\n                    return Err(WidthMustBeMultipleOfTwoForFormat(r.width()));\n                } else if r.height() % 2 != 0 {\n                    return Err(HeightMustBeMultipleOfTwoForFormat(r.height()));\n                }\n            }\n            _ => {}\n        };\n\n        // If the destination rectangle lies outside the texture boundaries,\n        // SDL_UpdateYUVTexture will write outside allocated texture memory.\n        let tex_info = self.query();\n        if let Some(ref r) = rect {\n            let tex_rect = Rect::new(0, 0, tex_info.width, tex_info.height);\n            let inside = match r.intersection(tex_rect) {\n                Some(intersection) => intersection == *r,\n                None => false,\n            };\n            // The destination rectangle cannot lie outside the texture boundaries\n            if !inside {\n                return Err(RectNotInsideTexture(r.clone()));\n            }\n        }\n\n        // We need the height in order to check the array slice lengths.\n        // Checking the lengths can prevent buffer overruns in SDL_UpdateYUVTexture.\n        let height = match rect {\n            Some(ref r) => r.height(),\n            None => tex_info.height,\n        } as usize;\n\n        //let wrong_length =\n        if y_plane.len() != (y_pitch * height) {\n            return Err(InvalidPlaneLength {\n                           plane: \"y\",\n                           length: y_plane.len(),\n                           pitch: y_pitch,\n                           height: height,\n                       });\n        }\n        if u_plane.len() != (u_pitch * height / 2) {\n            return Err(InvalidPlaneLength {\n                           plane: \"u\",\n                           length: u_plane.len(),\n                           pitch: u_pitch,\n                           height: height / 2,\n                       });\n        }\n        if v_plane.len() != (v_pitch * height / 2) {\n            return Err(InvalidPlaneLength {\n                           plane: \"v\",\n                           length: v_plane.len(),\n                           pitch: v_pitch,\n                           height: height / 2,\n                       });\n        }\n\n        let y_pitch = match validate_int(y_pitch as u32, \"y_pitch\") {\n            Ok(p) => p,\n            Err(_) => {\n                return Err(PitchOverflows {\n                               plane: \"y\",\n                               value: y_pitch,\n                           })\n            }\n        };\n        let u_pitch = match validate_int(u_pitch as u32, \"u_pitch\") {\n            Ok(p) => p,\n            Err(_) => {\n                return Err(PitchOverflows {\n                               plane: \"u\",\n                               value: u_pitch,\n                           })\n            }\n        };\n        let v_pitch = match validate_int(v_pitch as u32, \"v_pitch\") {\n            Ok(p) => p,\n            Err(_) => {\n                return Err(PitchOverflows {\n                               plane: \"v\",\n                               value: v_pitch,\n                           })\n            }\n        };\n\n        let result = unsafe {\n            ll::SDL_UpdateYUVTexture(self.raw,\n                                     rect_raw_ptr,\n                                     y_plane.as_ptr(),\n                                     y_pitch,\n                                     u_plane.as_ptr(),\n                                     u_pitch,\n                                     v_plane.as_ptr(),\n                                     v_pitch)\n        };\n        if result != 0 {\n            Err(SdlError(get_error()))\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Locks the texture for **write-only** pixel access.\n    /// The texture must have been created with streaming access.\n    ///\n    /// `F` is a function that is passed the write-only texture buffer,\n    /// and the pitch of the texture (size of a row in bytes).\n    /// # Remarks\n    /// As an optimization, the pixels made available for editing don't\n    /// necessarily contain the old texture data.\n    /// This is a write-only operation, and if you need to keep a copy of the\n    /// texture data you should do that at the application level.\n    pub fn with_lock<F, R, R2>(&mut self, rect: R2, func: F) -> Result<R, String>\n        where F: FnOnce(&mut [u8], usize) -> R,\n              R2: Into<Option<Rect>>\n    {\n        // Call to SDL to populate pixel data\n        let loaded = unsafe {\n            let q = self.query();\n            let mut pixels = ptr::null_mut();\n            let mut pitch = 0;\n\n            let (rect_raw_ptr, height) = match rect.into() {\n                Some(ref rect) => (rect.raw(), rect.height() as usize),\n                None => (ptr::null(), q.height as usize),\n            };\n\n            let ret = ll::SDL_LockTexture(self.raw, rect_raw_ptr, &mut pixels, &mut pitch);\n            if ret == 0 {\n                let size = q.format\n                    .byte_size_from_pitch_and_height(pitch as usize, height);\n                Ok((::std::slice::from_raw_parts_mut(pixels as *mut u8, size), pitch))\n            } else {\n                Err(get_error())\n            }\n        };\n\n        match loaded {\n            Ok((interior, pitch)) => {\n                let result;\n                unsafe {\n                    result = func(interior, pitch as usize);\n                    ll::SDL_UnlockTexture(self.raw);\n                }\n                Ok(result)\n            }\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Binds an OpenGL/ES/ES2 texture to the current\n    /// context for use with when rendering OpenGL primitives directly.\n    pub unsafe fn gl_bind_texture(&mut self) -> (f32, f32) {\n        let mut texw = 0.0;\n        let mut texh = 0.0;\n\n        if ll::SDL_GL_BindTexture(self.raw, &mut texw, &mut texh) == 0 {\n            (texw, texh)\n        } else {\n            panic!(\"OpenGL texture binding not supported\");\n        }\n    }\n\n    /// Unbinds an OpenGL/ES/ES2 texture from the current context.\n    pub unsafe fn gl_unbind_texture(&mut self) {\n        if ll::SDL_GL_UnbindTexture(self.raw) != 0 {\n            panic!(\"OpenGL texture unbinding not supported\");\n        }\n    }\n\n    /// Binds and unbinds an OpenGL/ES/ES2 texture from the current context.\n    pub fn gl_with_bind<R, F: FnOnce(f32, f32) -> R>(&mut self, f: F) -> R {\n        unsafe {\n            let mut texw = 0.0;\n            let mut texh = 0.0;\n\n            if ll::SDL_GL_BindTexture(self.raw, &mut texw, &mut texh) == 0 {\n                let return_value = f(texw, texh);\n\n                if ll::SDL_GL_UnbindTexture(self.raw) == 0 {\n                    return_value\n                } else {\n                    // This should never happen...\n                    panic!();\n                }\n            } else {\n                panic!(\"OpenGL texture binding not supported\");\n            }\n        }\n    }\n\n    pub fn raw(&self) -> *mut ll::SDL_Texture {\n        self.raw\n    }\n}\n\n#[derive(Copy, Clone)]\npub struct DriverIterator {\n    length: i32,\n    index: i32,\n}\n\nimpl Iterator for DriverIterator {\n    type Item = RendererInfo;\n\n    #[inline]\n    fn next(&mut self) -> Option<RendererInfo> {\n        if self.index >= self.length {\n            None\n        } else {\n            let mut out = unsafe { mem::uninitialized() };\n            let result = unsafe { ll::SDL_GetRenderDriverInfo(self.index, &mut out) == 0 };\n            assert!(result, 0);\n            self.index += 1;\n\n            unsafe { Some(RendererInfo::from_ll(&out)) }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let l = self.length as usize;\n        (l, Some(l))\n    }\n}\n\nimpl ExactSizeIterator for DriverIterator {}\n\n/// Gets an iterator of all render drivers compiled into the SDL2 library.\n#[inline]\npub fn drivers() -> DriverIterator {\n    // This function is thread-safe and doesn't require the video subsystem to be initialized.\n    // The list of drivers are read-only and statically compiled into SDL2, varying by platform.\n\n    // SDL_GetNumRenderDrivers can never return a negative value.\n    DriverIterator {\n        length: unsafe { ll::SDL_GetNumRenderDrivers() },\n        index: 0,\n    }\n}\n",null,"#![crate_name = \"sdl2\"]\n#![crate_type = \"lib\"]\n\nextern crate num;\npub extern crate libc;\n\n#[macro_use]\nextern crate lazy_static;\n\n#[macro_use]\nextern crate bitflags;\npub extern crate sdl2_sys as sys;\n\n#[cfg(feature = \"gfx\")]\nextern crate c_vec;\n\npub use sdl::*;\n\npub mod clipboard;\npub mod cpuinfo;\n#[macro_use] pub mod macros;\npub mod event;\npub mod filesystem;\npub mod gesture;\npub mod touch;\npub mod joystick;\npub mod controller;\npub mod haptic;\npub mod keyboard;\npub mod mouse;\npub mod rect;\npub mod surface;\npub mod pixels;\npub mod video;\npub mod timer;\npub mod render;\npub mod rwops;\npub mod log;\nmod sdl;\npub mod audio;\npub mod version;\npub mod messagebox;\npub mod hint;\n\n// modules\n#[cfg(feature = \"ttf\")]\npub mod ttf;\n#[cfg(feature = \"image\")]\npub mod image;\n#[cfg(feature = \"mixer\")]\npub mod mixer;\n#[cfg(feature = \"gfx\")]\npub mod gfx;\n\nmod common;\n// Export return types and such from the common module.\npub use common::IntegerOrSdlError;\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,"use std::error;\nuse std::ffi::{CStr, CString, NulError};\nuse std::fmt;\nuse std::rc::Rc;\nuse libc::c_char;\n\nuse sys::sdl as ll;\n\n#[repr(i32)]\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\npub enum Error {\n    NoMemError = ll::SDL_ENOMEM as i32,\n    ReadError = ll::SDL_EFREAD as i32,\n    WriteError = ll::SDL_EFWRITE as i32,\n    SeekError = ll::SDL_EFSEEK as i32,\n    UnsupportedError = ll::SDL_UNSUPPORTED as i32\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::Error::*;\n\n        match *self {\n            NoMemError => write!(f, \"Out of memory\"),\n            ReadError => write!(f, \"Error reading from datastream\"),\n            WriteError => write!(f, \"Error writing to datastream\"),\n            SeekError => write!(f, \"Error seeking in datastream\"),\n            UnsupportedError => write!(f, \"Unknown SDL error\")\n        }\n    }\n}\n\nimpl error::Error for Error {\n    fn description(&self) -> &str {\n        use self::Error::*;\n\n        match *self {\n            NoMemError => \"out of memory\",\n            ReadError => \"error reading from datastream\",\n            WriteError => \"error writing to datastream\",\n            SeekError => \"error seeking in datastream\",\n            UnsupportedError => \"unknown SDL error\"\n        }\n    }\n}\n\nuse std::sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT};\n/// Only one Sdl context can be alive at a time.\n/// Set to false by default (not alive).\nstatic IS_SDL_CONTEXT_ALIVE: AtomicBool = ATOMIC_BOOL_INIT;\n\n/// The SDL context type. Initialize with `sdl2::init()`.\n///\n/// From a thread-safety perspective, `Sdl` represents the main thread.\n/// As such, `Sdl` is a useful type for ensuring that SDL types that can only\n/// be used on the main thread are initialized that way.\n///\n/// For instance, `SDL_PumpEvents()` is not thread safe, and may only be\n/// called on the main thread.\n/// All functionality that calls `SDL_PumpEvents()` is thus put into an\n/// `EventPump` type, which can only be obtained through `Sdl`.\n/// This guarantees that the only way to call event-pumping functions is on\n/// the main thread.\n#[derive(Clone)]\npub struct Sdl {\n    sdldrop: Rc<SdlDrop>\n}\n\nimpl Sdl {\n    #[inline]\n    fn new() -> Result<Sdl, String> {\n        unsafe {\n            use std::sync::atomic::Ordering;\n\n            // Atomically switch the `IS_SDL_CONTEXT_ALIVE` global to true\n            let was_alive = IS_SDL_CONTEXT_ALIVE.swap(true, Ordering::Relaxed);\n\n            if was_alive {\n                Err(\"Cannot initialize `Sdl` more than once at a time.\".to_owned())\n            } else {\n                // Initialize SDL without any explicit subsystems (flags = 0).\n                if ll::SDL_Init(0) == 0 {\n                    Ok(Sdl {\n                        sdldrop: Rc::new(SdlDrop)\n                    })\n                } else {\n                    IS_SDL_CONTEXT_ALIVE.swap(false, Ordering::Relaxed);\n                    Err(get_error())\n                }\n            }\n        }\n    }\n\n    /// Initializes the audio subsystem.\n    #[inline]\n    pub fn audio(&self) -> Result<AudioSubsystem, String> { AudioSubsystem::new(self) }\n\n    /// Initializes the event subsystem.\n    #[inline]\n    pub fn event(&self) -> Result<EventSubsystem, String> { EventSubsystem::new(self) }\n\n    /// Initializes the joystick subsystem.\n    #[inline]\n    pub fn joystick(&self) -> Result<JoystickSubsystem, String> { JoystickSubsystem::new(self) }\n\n    /// Initializes the haptic subsystem.\n    #[inline]\n    pub fn haptic(&self) -> Result<HapticSubsystem, String> { HapticSubsystem::new(self) }\n\n    /// Initializes the game controller subsystem.\n    #[inline]\n    pub fn game_controller(&self) -> Result<GameControllerSubsystem, String> { GameControllerSubsystem::new(self) }\n\n    /// Initializes the timer subsystem.\n    #[inline]\n    pub fn timer(&self) -> Result<TimerSubsystem, String> { TimerSubsystem::new(self) }\n\n    /// Initializes the video subsystem.\n    #[inline]\n    pub fn video(&self) -> Result<VideoSubsystem, String> { VideoSubsystem::new(self) }\n\n    /// Obtains the SDL event pump.\n    ///\n    /// At most one `EventPump` is allowed to be alive during the program's execution.\n    /// If this function is called while an `EventPump` instance is alive, the function will return\n    /// an error.\n    #[inline]\n    pub fn event_pump(&self) -> Result<EventPump, String> {\n        EventPump::new(self)\n    }\n\n    #[inline]\n    #[doc(hidden)]\n    pub fn sdldrop(&self) -> Rc<SdlDrop> {\n        self.sdldrop.clone()\n    }\n}\n\n/// When SDL is no longer in use (the refcount in an `Rc<SdlDrop>` reaches 0), the library is quit.\n#[doc(hidden)]\n#[derive(Debug)]\npub struct SdlDrop;\n\nimpl Drop for SdlDrop {\n    #[inline]\n    fn drop(&mut self) {\n        use std::sync::atomic::Ordering;\n\n        let was_alive = IS_SDL_CONTEXT_ALIVE.swap(false, Ordering::Relaxed);\n        assert!(was_alive);\n\n        unsafe { ll::SDL_Quit(); }\n    }\n}\n\n// No subsystem can implement `Send` because the destructor, `SDL_QuitSubSystem`,\n// utilizes non-atomic reference counting and should thus be called on a single thread.\n// Some subsystems have functions designed to be thread-safe, such as adding a timer or accessing\n// the event queue. These subsystems implement `Sync`.\n\nmacro_rules! subsystem {\n    ($name:ident, $flag:expr) => (\n        impl $name {\n            #[inline]\n            fn new(sdl: &Sdl) -> Result<$name, String> {\n                let result = unsafe { ll::SDL_InitSubSystem($flag) };\n\n                if result == 0 {\n                    Ok($name {\n                        _subsystem_drop: Rc::new(SubsystemDrop {\n                            _sdldrop: sdl.sdldrop.clone(),\n                            flag: $flag\n                        })\n                    })\n                } else {\n                    Err(get_error())\n                }\n            }\n        }\n    );\n    ($name:ident, $flag:expr, nosync) => (\n        #[derive(Debug, Clone)]\n        pub struct $name {\n            /// Subsystems cannot be moved or (usually) used on non-main threads.\n            /// Luckily, Rc restricts use to the main thread.\n            _subsystem_drop: Rc<SubsystemDrop>\n        }\n\n        impl $name {\n            /// Obtain an SDL context.\n            #[inline]\n            pub fn sdl(&self) -> Sdl {\n                Sdl { sdldrop: self._subsystem_drop._sdldrop.clone() }\n            }\n        }\n\n        subsystem!($name, $flag);\n    );\n    ($name:ident, $flag:expr, sync) => (\n        pub struct $name {\n            /// Subsystems cannot be moved or (usually) used on non-main threads.\n            /// Luckily, Rc restricts use to the main thread.\n            _subsystem_drop: Rc<SubsystemDrop>\n        }\n        unsafe impl Sync for $name {}\n\n        impl $name {\n            #[inline]\n            pub fn clone(&self) -> $name {\n                $name {\n                    _subsystem_drop: self._subsystem_drop.clone()\n                }\n            }\n\n            /// Obtain an SDL context.\n            #[inline]\n            pub fn sdl(&self) -> Sdl {\n                Sdl { sdldrop: self._subsystem_drop._sdldrop.clone() }\n            }\n        }\n\n        subsystem!($name, $flag);\n    )\n}\n\n/// When a subsystem is no longer in use (the refcount in an `Rc<SubsystemDrop>` reaches 0),\n/// the subsystem is quit.\n#[derive(Debug, Clone)]\nstruct SubsystemDrop {\n    _sdldrop: Rc<SdlDrop>,\n    flag: ll::SDL_InitFlag\n}\n\nimpl Drop for SubsystemDrop {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe { ll::SDL_QuitSubSystem(self.flag); }\n    }\n}\n\nsubsystem!(AudioSubsystem, ll::SDL_INIT_AUDIO, nosync);\nsubsystem!(GameControllerSubsystem, ll::SDL_INIT_GAMECONTROLLER, nosync);\nsubsystem!(HapticSubsystem, ll::SDL_INIT_HAPTIC, nosync);\nsubsystem!(JoystickSubsystem, ll::SDL_INIT_JOYSTICK, nosync);\nsubsystem!(VideoSubsystem, ll::SDL_INIT_VIDEO, nosync);\n// Timers can be added on other threads.\nsubsystem!(TimerSubsystem, ll::SDL_INIT_TIMER, sync);\n// The event queue can be read from other threads.\nsubsystem!(EventSubsystem, ll::SDL_INIT_EVENTS, sync);\n\nstatic mut IS_EVENT_PUMP_ALIVE: bool = false;\n\n/// A thread-safe type that encapsulates SDL event-pumping functions.\npub struct EventPump {\n    _sdldrop: Rc<SdlDrop>\n}\n\nimpl EventPump {\n    /// Obtains the SDL event pump.\n    #[inline]\n    fn new(sdl: &Sdl) -> Result<EventPump, String> {\n        // Called on the main SDL thread.\n\n        unsafe {\n            if IS_EVENT_PUMP_ALIVE {\n                Err(\"an `EventPump` instance is already alive - there can only be one `EventPump` in use at a time.\".to_owned())\n            } else {\n                // Initialize the events subsystem, just in case none of the other subsystems have done it yet.\n                let result = ll::SDL_InitSubSystem(ll::SDL_INIT_EVENTS);\n\n                if result == 0 {\n                    IS_EVENT_PUMP_ALIVE = true;\n\n                    Ok(EventPump {\n                        _sdldrop: sdl.sdldrop.clone()\n                    })\n                } else {\n                    Err(get_error())\n                }\n            }\n        }\n    }\n}\n\nimpl Drop for EventPump {\n    #[inline]\n    fn drop(&mut self) {\n        // Called on the main SDL thread.\n\n        unsafe {\n            assert!(IS_EVENT_PUMP_ALIVE);\n            ll::SDL_QuitSubSystem(ll::SDL_INIT_EVENTS);\n            IS_EVENT_PUMP_ALIVE = false;\n        }\n    }\n}\n\n/// Initializes the SDL library.\n/// This must be called before using any other SDL function.\n///\n/// # Example\n/// ```no_run\n/// let sdl_context = sdl2::init().unwrap();\n/// let mut event_pump = sdl_context.event_pump().unwrap();\n///\n/// for event in event_pump.poll_iter() {\n///     // ...\n/// }\n///\n/// // SDL_Quit() is called here as `sdl_context` is dropped.\n/// ```\n#[inline]\npub fn init() -> Result<Sdl, String> { Sdl::new() }\n\npub fn get_error() -> String {\n    unsafe {\n        let err = ll::SDL_GetError();\n        CStr::from_ptr(err as *const _).to_str().unwrap().to_owned()\n    }\n}\n\npub fn set_error(err: &str) -> Result<(), NulError> {\n    let c_string = try!(CString::new(err));\n    Ok(unsafe {\n        ll::SDL_SetError(c_string.as_ptr() as *const c_char);\n    })\n}\n\npub fn set_error_from_code(err: Error) {\n    unsafe { ll::SDL_Error(err as ll::SDL_errorcode); }\n}\n\npub fn clear_error() {\n    unsafe { ll::SDL_ClearError(); }\n}\n","//! Rectangles and points.\n#![allow(const_err)]\n\nuse sys::rect as ll;\nuse std::mem;\nuse std::ptr;\nuse std::ops::{Deref, DerefMut, Add, BitAnd, BitOr, Div, Mul, Neg, Sub};\nuse std::convert::{AsRef, AsMut};\n\n/// The maximal integer value that can be used for rectangles.\n///\n/// This value is smaller than strictly needed, but is useful in ensuring that\n/// rect sizes will never have to be truncated when clamping.\npub fn max_int_value() -> u32 {\n    i32::max_value() as u32 / 2\n}\n\n/// The minimal integer value that can be used for rectangle positions\n/// and points.\n///\n/// This value is needed, because otherwise the width of a rectangle created\n/// from a point would be able to exceed the maximum width.\npub fn min_int_value() -> i32 {\n    i32::min_value() / 2\n}\n\nfn clamp_size(val: u32) -> u32 {\n    if val == 0 {\n        1\n    } else if val > max_int_value() {\n        max_int_value()\n    } else {\n        val\n    }\n}\n\nfn clamp_position(val: i32) -> i32 {\n    if val > max_int_value() as i32 {\n        max_int_value() as i32\n    } else if val < min_int_value() {\n        min_int_value()\n    } else {\n        val\n    }\n}\n\nfn clamped_mul(a: i32, b: i32) -> i32 {\n    match a.checked_mul(b) {\n        Some(val) => val,\n        None => {\n            if (a < 0) ^ (b < 0) {\n                min_int_value()\n            } else {\n                max_int_value() as i32\n            }\n        }\n    }\n}\n\n/// A (non-empty) rectangle.\n///\n/// The width and height of a `Rect` must always be strictly positive (never\n/// zero).  In cases where empty rects may need to represented, it is\n/// recommended to use `Option<Rect>`, with `None` representing an empty\n/// rectangle (see, for example, the output of the\n/// [`intersection`](#method.intersection) method).\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct Rect {\n    raw: ll::SDL_Rect,\n}\n\nimpl Rect {\n    /// Creates a new rectangle from the given values.\n    ///\n    /// The width and height are clamped to ensure that the right and bottom\n    /// sides of the rectangle does not exceed i32::max_value() (the value\n    /// 2147483647, the maximal positive size of an i32).  This means that the\n    /// rect size will behave oddly if you move it very far to the right or\n    /// downwards on the screen.\n    ///\n    /// `Rect`s must always be non-empty, so a `width` and/or `height` argument\n    /// of 0 will be replaced with 1.\n    pub fn new(x: i32, y: i32, width: u32, height: u32) -> Rect {\n        let raw = ll::SDL_Rect {\n            x: clamp_position(x),\n            y: clamp_position(y),\n            w: clamp_size(width) as i32,\n            h: clamp_size(height) as i32,\n        };\n        Rect { raw: raw }\n    }\n\n    /// Creates a new rectangle centered on the given position.\n    ///\n    /// The width and height are clamped to ensure that the right and bottom\n    /// sides of the rectangle does not exceed i32::max_value() (the value\n    /// 2147483647, the maximal positive size of an i32).  This means that the\n    /// rect size will behave oddly if you move it very far to the right or\n    /// downwards on the screen.\n    ///\n    /// `Rect`s must always be non-empty, so a `width` and/or `height` argument\n    /// of 0 will be replaced with 1.\n    pub fn from_center<P>(center: P, width: u32, height: u32)\n            -> Rect where P: Into<Point> {\n        let raw = ll::SDL_Rect {\n            x: 0,\n            y: 0,\n            w: clamp_size(width) as i32,\n            h: clamp_size(height) as i32,\n        };\n        let mut rect = Rect { raw: raw };\n        rect.center_on(center.into());\n        rect\n    }\n\n    /// The horizontal position of this rectangle.\n    pub fn x(&self) -> i32 {\n        self.raw.x\n    }\n\n    /// The vertical position of this rectangle.\n    pub fn y(&self) -> i32 {\n        self.raw.y\n    }\n\n    /// The width of this rectangle.\n    pub fn width(&self) -> u32 {\n        self.raw.w as u32\n    }\n\n    /// The height of this rectangle.\n    pub fn height(&self) -> u32 {\n        self.raw.h as u32\n    }\n\n    /// Returns the width and height of this rectangle.\n    pub fn size(&self) -> (u32, u32) {\n        (self.width(), self.height())\n    }\n\n    /// Sets the horizontal position of this rectangle to the given value,\n    /// clamped to be less than or equal to i32::max_value() / 2.\n    pub fn set_x(&mut self, x: i32) {\n        self.raw.x = clamp_position(x);\n    }\n\n    /// Sets the vertical position of this rectangle to the given value,\n    /// clamped to be less than or equal to i32::max_value() / 2.\n    pub fn set_y(&mut self, y: i32) {\n        self.raw.y = clamp_position(y);\n    }\n\n    /// Sets the width of this rectangle to the given value,\n    /// clamped to be less than or equal to i32::max_value() / 2.\n    ///\n    /// `Rect`s must always be non-empty, so a `width` argument of 0 will be\n    /// replaced with 1.\n    pub fn set_width(&mut self, width: u32) {\n        self.raw.w = clamp_size(width) as i32;\n    }\n\n    /// Sets the height of this rectangle to the given value,\n    /// clamped to be less than or equal to i32::max_value() / 2.\n    ///\n    /// `Rect`s must always be non-empty, so a `height` argument of 0 will be\n    /// replaced with 1.\n    pub fn set_height(&mut self, height: u32) {\n        self.raw.h = clamp_size(height) as i32;\n    }\n\n    /// Returns the x-position of the left side of this rectangle.\n    pub fn left(&self) -> i32 {\n        self.raw.x\n    }\n\n    /// Returns the x-position of the right side of this rectangle.\n    pub fn right(&self) -> i32 {\n        self.raw.x + self.raw.w\n    }\n\n    /// Returns the y-position of the top side of this rectangle.\n    pub fn top(&self) -> i32 {\n        self.raw.y\n    }\n\n    /// Returns the y-position of the bottom side of this rectangle.\n    pub fn bottom(&self) -> i32 {\n        self.raw.y + self.raw.h\n    }\n\n    /// Returns the center position of this rectangle.\n    ///\n    /// Note that if the width or height is not a multiple of two,\n    /// the center will be rounded down.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use sdl2::rect::{Rect,Point};\n    /// let rect = Rect::new(1,0,2,3);\n    /// assert_eq!(Point::new(2,1),rect.center());\n    /// ```\n    pub fn center(&self) -> Point {\n        let x = self.raw.x + (self.raw.w / 2);\n        let y = self.raw.y + (self.raw.h / 2);\n        Point::new(x, y)\n    }\n\n    /// Returns the top-left corner of this rectangle.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use sdl2::rect::{Rect, Point};\n    /// let rect = Rect::new(1, 0, 2, 3);\n    /// assert_eq!(Point::new(1, 0), rect.top_left());\n    /// ```\n    pub fn top_left(&self) -> Point {\n        Point::new(self.left(), self.top())\n    }\n\n    /// Returns the top-right corner of this rectangle.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use sdl2::rect::{Rect, Point};\n    /// let rect = Rect::new(1, 0, 2, 3);\n    /// assert_eq!(Point::new(3, 0), rect.top_right());\n    /// ```\n    pub fn top_right(&self) -> Point {\n        Point::new(self.right(), self.top())\n    }\n\n    /// Returns the bottom-left corner of this rectangle.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use sdl2::rect::{Rect, Point};\n    /// let rect = Rect::new(1, 0, 2, 3);\n    /// assert_eq!(Point::new(1, 3), rect.bottom_left());\n    /// ```\n    pub fn bottom_left(&self) -> Point {\n        Point::new(self.left(), self.bottom())\n    }\n\n    /// Returns the bottom-right corner of this rectangle.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use sdl2::rect::{Rect, Point};\n    /// let rect = Rect::new(1, 0, 2, 3);\n    /// assert_eq!(Point::new(3, 3), rect.bottom_right());\n    /// ```\n    pub fn bottom_right(&self) -> Point {\n        Point::new(self.right(), self.bottom())\n    }\n\n    /// Sets the position of the right side of this rectangle to the given\n    /// value, clamped to be less than or equal to i32::max_value() / 2.\n    pub fn set_right(&mut self, right: i32) {\n        self.raw.x = clamp_position(clamp_position(right) - self.raw.w);\n    }\n\n    /// Sets the position of the bottom side of this rectangle to the given\n    /// value, clamped to be less than or equal to i32::max_value() / 2.\n    pub fn set_bottom(&mut self, bottom: i32) {\n        self.raw.y = clamp_position(clamp_position(bottom) - self.raw.h);\n    }\n\n    /// Centers the rectangle on the given point.\n    pub fn center_on<P>(&mut self, point: P) where P: Into<(i32, i32)> {\n        let (x, y) = point.into();\n        self.raw.x = clamp_position(clamp_position(x) - self.raw.w / 2);\n        self.raw.y = clamp_position(clamp_position(y) - self.raw. h / 2);\n    }\n\n    /// Move this rect and clamp the positions to prevent over/underflow.\n    /// This also clamps the size to prevent overflow.\n    pub fn offset(&mut self, x: i32, y: i32) {\n        match self.raw.x.checked_add(x) {\n            Some(val) => self.raw.x = clamp_position(val),\n            None => {\n                if x >= 0 {\n                    self.raw.x = max_int_value() as i32;\n                } else {\n                    self.raw.x = i32::min_value();\n                }\n            },\n        }\n        match self.raw.y.checked_add(y) {\n            Some(val) => self.raw.y = clamp_position(val),\n            None => {\n                if y >= 0 {\n                    self.raw.y = max_int_value() as i32;\n                } else {\n                    self.raw.y = i32::min_value();\n                }\n            },\n        }\n    }\n\n    /// Moves this rect to the given position after clamping the values.\n    pub fn reposition<P>(&mut self, point: P) where P: Into<(i32, i32)> {\n        let (x, y) = point.into();\n        self.raw.x = clamp_position(x);\n        self.raw.y = clamp_position(y);\n    }\n\n    /// Resizes this rect to the given size after clamping the values.\n    pub fn resize(&mut self, width: u32, height: u32) {\n        self.raw.w = clamp_size(width) as i32;\n        self.raw.h = clamp_size(height) as i32;\n    }\n\n    /// Checks whether this rect contains a given point, or touches it on the\n    /// right and/or bottom edges.  This method is deprecated in favor of\n    /// [`Rect::contains_point`](#method.contains_point).\n    ///\n    /// For [historical\n    /// reasons](https://github.com/AngryLawyer/rust-sdl2/issues/569), this\n    /// method differs in behavior from\n    /// [`SDL_PointInRect`](https://wiki.libsdl.org/SDL_PointInRect) by\n    /// including points along the bottom and right edges of the rectangle, so\n    /// that a 1-by-1 rectangle actually covers an area of four points, not\n    /// one.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use sdl2::rect::{Rect, Point};\n    /// let rect = Rect::new(1, 2, 3, 4);\n    /// assert!(rect.contains(Point::new(1, 2)));\n    /// assert!(!rect.contains(Point::new(0, 1)));\n    /// assert!(rect.contains(Point::new(3, 5)));\n    /// assert!(rect.contains(Point::new(4, 6)));  // N.B.\n    /// assert!(!rect.contains(Point::new(5, 7)));\n    /// ```\n    #[deprecated(since = \"0.30.0\", note = \"use `contains_point` instead\")]\n    pub fn contains<P>(&self, point: P) -> bool where P: Into<(i32, i32)> {\n        let (x, y) = point.into();\n        let inside_x = x >= self.left() && x <= self.right();\n        inside_x && (y >= self.top() && y <= self.bottom())\n    }\n\n    /// Checks whether this rectangle contains a given point.\n    ///\n    /// Points along the right and bottom edges are not considered to be inside\n    /// the rectangle; this way, a 1-by-1 rectangle contains only a single\n    /// point.  Another way to look at it is that this method returns true if\n    /// and only if the given point would be painted by a call to\n    /// [`Renderer::fill_rect`](\n    /// ../render/struct.Renderer.html#method.fill_rect).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use sdl2::rect::{Rect, Point};\n    /// let rect = Rect::new(1, 2, 3, 4);\n    /// assert!(rect.contains_point(Point::new(1, 2)));\n    /// assert!(!rect.contains_point(Point::new(0, 1)));\n    /// assert!(rect.contains_point(Point::new(3, 5)));\n    /// assert!(!rect.contains_point(Point::new(4, 6)));\n    /// ```\n    pub fn contains_point<P>(&self, point: P) -> bool\n            where P: Into<(i32, i32)> {\n        let (x, y) = point.into();\n        let inside_x = x >= self.left() && x < self.right();\n        inside_x && (y >= self.top() && y < self.bottom())\n    }\n\n    /// Checks whether this rectangle completely contains another rectangle.\n    ///\n    /// This method returns true if and only if every point contained by\n    /// `other` is also contained by `self`; in other words, if the\n    /// intersection of `self` and `other` is equal to `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use sdl2::rect::Rect;\n    /// let rect = Rect::new(1, 2, 3, 4);\n    /// assert!(rect.contains_rect(rect));\n    /// assert!(rect.contains_rect(Rect::new(3, 3, 1, 1)));\n    /// assert!(!rect.contains_rect(Rect::new(2, 1, 1, 1)));\n    /// assert!(!rect.contains_rect(Rect::new(3, 3, 2, 1)));\n    /// ```\n    pub fn contains_rect(&self, other: Rect) -> bool {\n        other.left() >= self.left() && other.right() <= self.right() &&\n            other.top() >= self.top() && other.bottom() <= self.bottom()\n    }\n\n    /// Returns the underlying C Rect.\n    pub fn raw(&self) -> *const ll::SDL_Rect {\n        &self.raw\n    }\n\n    pub fn raw_mut(&mut self) -> *mut ll::SDL_Rect {\n        self.raw() as *mut _\n    }\n\n    pub fn raw_slice(slice: &[Rect]) -> *const ll::SDL_Rect {\n        unsafe {\n            mem::transmute(slice.as_ptr())\n        }\n    }\n\n    pub fn from_ll(raw: ll::SDL_Rect) -> Rect {\n        Rect::new(raw.x, raw.y, raw.w as u32, raw.h as u32)\n    }\n\n    /// Calculate a minimal rectangle enclosing a set of points.\n    /// If a clipping rectangle is given, only points that are within it will be\n    /// considered.\n    pub fn from_enclose_points<R: Into<Option<Rect>>>(points: &[Point], clipping_rect: R)\n            -> Option<Rect>\n    where R: Into<Option<Rect>>\n    {\n        let clipping_rect = clipping_rect.into();\n\n        if points.len() == 0 {\n            return None;\n        }\n\n        let mut out = unsafe {\n            mem::uninitialized()\n        };\n\n        let clip_ptr = match clipping_rect.as_ref() {\n            Some(r) => r.raw(),\n            None => ptr::null()\n        };\n\n        let result = unsafe {\n            ll::SDL_EnclosePoints(\n                Point::raw_slice(points),\n                points.len() as i32,\n                clip_ptr,\n                &mut out\n            ) != 0\n        };\n\n        if result {\n            // Return an error if the dimensions are too large.\n            Some(Rect::from_ll(out))\n        } else {\n            None\n        }\n    }\n\n    /// Determines whether two rectangles intersect.\n    ///\n    /// Rectangles that share an edge but don't actually overlap are not\n    /// considered to intersect.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use sdl2::rect::Rect;\n    /// let rect = Rect::new(0, 0, 5, 5);\n    /// assert!(rect.has_intersection(rect));\n    /// assert!(rect.has_intersection(Rect::new(2, 2, 5, 5)));\n    /// assert!(!rect.has_intersection(Rect::new(5, 0, 5, 5)));\n    /// ```\n    pub fn has_intersection(&self, other: Rect) -> bool {\n        unsafe {\n            ll::SDL_HasIntersection(self.raw(), other.raw()) != 0\n        }\n    }\n\n    /// Calculates the intersection of two rectangles.\n    ///\n    /// Returns `None` if the two rectangles don't intersect.  Rectangles that\n    /// share an edge but don't actually overlap are not considered to\n    /// intersect.\n    ///\n    /// The bitwise AND operator `&` can also be used.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use sdl2::rect::Rect;\n    /// let rect = Rect::new(0, 0, 5, 5);\n    /// assert_eq!(rect.intersection(rect), Some(rect));\n    /// assert_eq!(rect.intersection(Rect::new(2, 2, 5, 5)),\n    ///            Some(Rect::new(2, 2, 3, 3)));\n    /// assert_eq!(rect.intersection(Rect::new(5, 0, 5, 5)), None);\n    /// ```\n    pub fn intersection(&self, other: Rect) -> Option<Rect> {\n        let mut out = unsafe { mem::uninitialized() };\n\n        let success = unsafe {\n            ll::SDL_IntersectRect(self.raw(), other.raw(), &mut out) != 0\n        };\n\n        if success {\n            Some(Rect::from_ll(out))\n        } else {\n            None\n        }\n    }\n\n    /// Calculates the union of two rectangles (i.e. the smallest rectangle\n    /// that contains both).\n    ///\n    /// The bitwise OR operator `|` can also be used.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use sdl2::rect::Rect;\n    /// let rect = Rect::new(0, 0, 5, 5);\n    /// assert_eq!(rect.union(rect), rect);\n    /// assert_eq!(rect.union(Rect::new(2, 2, 5, 5)), Rect::new(0, 0, 7, 7));\n    /// assert_eq!(rect.union(Rect::new(5, 0, 5, 5)), Rect::new(0, 0, 10, 5));\n    /// ```\n    pub fn union(&self, other: Rect) -> Rect {\n        let mut out = unsafe {\n            mem::uninitialized()\n        };\n\n        unsafe {\n            // If `self` and `other` are both empty, `out` remains uninitialized.\n            // Because empty rectangles aren't allowed in Rect, we don't need to worry about this.\n            ll::SDL_UnionRect(self.raw(), other.raw(), &mut out)\n        };\n\n        Rect::from_ll(out)\n    }\n\n    /// Calculates the intersection of a rectangle and a line segment and\n    /// returns the points of their intersection.\n    pub fn intersect_line(&self, start: Point, end: Point)\n            -> Option<(Point, Point)> {\n\n        let (mut start_x, mut start_y) = (start.x(), start.y());\n        let (mut end_x, mut end_y) = (end.x(), end.y());\n\n        let intersected = unsafe {\n            ll::SDL_IntersectRectAndLine(\n                self.raw(),\n                &mut start_x, &mut start_y,\n                &mut end_x, &mut end_y\n            ) != 0\n        };\n\n        if intersected {\n            Some((Point::new(start_x, start_y), Point::new(end_x, end_y)))\n        } else {\n            None\n        }\n    }\n}\n\nimpl Deref for Rect {\n    type Target = ll::SDL_Rect;\n\n    /// # Example\n    ///\n    /// ```rust\n    /// use sdl2::rect::Rect;\n    /// let rect = Rect::new(2, 3, 4, 5);\n    /// assert_eq!(2, rect.x);\n    /// ```\n    fn deref(&self) -> &ll::SDL_Rect {\n        &self.raw\n    }\n}\n\nimpl DerefMut for Rect {\n    /// # Example\n    ///\n    /// ```rust\n    /// use sdl2::rect::Rect;\n    /// let mut rect = Rect::new(2, 3, 4, 5);\n    /// rect.x = 60;\n    /// assert_eq!(60, rect.x);\n    /// ```\n    fn deref_mut(&mut self) -> &mut ll::SDL_Rect {\n        &mut self.raw\n    }\n}\n\nimpl Into<ll::SDL_Rect> for Rect {\n    fn into(self) -> ll::SDL_Rect {\n        self.raw\n    }\n}\n\nimpl Into<(i32, i32, u32, u32)> for Rect {\n    fn into(self) -> (i32, i32, u32, u32) {\n        (self.raw.x, self.raw.y, self.raw.w as u32, self.raw.h as u32)\n    }\n}\n\nimpl From<ll::SDL_Rect> for Rect {\n    fn from(raw: ll::SDL_Rect) -> Rect {\n        Rect { raw: raw }\n    }\n}\n\nimpl From<(i32, i32, u32, u32)> for Rect {\n    fn from((x, y, width, height): (i32, i32, u32, u32)) -> Rect {\n        Rect::new(x, y, width, height)\n    }\n}\n\nimpl AsRef<ll::SDL_Rect> for Rect {\n    fn as_ref(&self) -> &ll::SDL_Rect {\n        &self.raw\n    }\n}\n\nimpl AsMut<ll::SDL_Rect> for Rect {\n    fn as_mut(&mut self) -> &mut ll::SDL_Rect {\n        &mut self.raw\n    }\n}\n\n// Intersection\nimpl BitAnd<Rect> for Rect {\n    type Output = Option<Rect>;\n    fn bitand(self, rhs: Rect) -> Option<Rect> { self.intersection(rhs) }\n}\n\n// Union\nimpl BitOr<Rect> for Rect {\n    type Output = Rect;\n    fn bitor(self, rhs: Rect) -> Rect { self.union(rhs) }\n}\n\n/// Immutable point type, consisting of x and y.\n#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash)]\npub struct Point {\n    raw: ll::SDL_Point\n}\n\nimpl Deref for Point {\n    type Target = ll::SDL_Point;\n\n    /// # Example\n    ///\n    /// ```rust\n    /// use sdl2::rect::Point;\n    /// let point = Point::new(2, 3);\n    /// assert_eq!(2, point.x);\n    /// ```\n    fn deref(&self) -> &ll::SDL_Point {\n        &self.raw\n    }\n}\n\nimpl DerefMut for Point {\n    /// # Example\n    ///\n    /// ```rust\n    /// use sdl2::rect::Point;\n    /// let mut point = Point::new(2, 3);\n    /// point.x = 4;\n    /// assert_eq!(4, point.x);\n    /// ```\n    fn deref_mut(&mut self) -> &mut ll::SDL_Point {\n        &mut self.raw\n    }\n}\n\nimpl AsRef<ll::SDL_Point> for Point {\n    fn as_ref(&self) -> &ll::SDL_Point {\n        &self.raw\n    }\n}\n\nimpl AsMut<ll::SDL_Point> for Point {\n    fn as_mut(&mut self) -> &mut ll::SDL_Point {\n        &mut self.raw\n    }\n}\n\nimpl From<ll::SDL_Point> for Point {\n    fn from(prim: ll::SDL_Point) -> Point {\n        Point { raw: prim }\n    }\n}\n\nimpl From<(i32, i32)> for Point {\n    fn from((x, y): (i32, i32)) -> Point {\n        Point::new(x, y)\n    }\n}\n\nimpl Into<ll::SDL_Point> for Point {\n    fn into(self) -> ll::SDL_Point {\n        self.raw\n    }\n}\n\nimpl Into<(i32, i32)> for Point {\n    fn into(self) -> (i32, i32) {\n        (self.x(), self.y())\n    }\n}\n\nimpl Point {\n    /// Creates a new point from the given coordinates.\n    pub fn new(x: i32, y: i32) -> Point {\n        Point {\n            raw: ll::SDL_Point {\n                x: clamp_position(x),\n                y: clamp_position(y),\n            }\n        }\n    }\n\n    pub fn from_ll(raw: ll::SDL_Point) -> Point {\n        Point::new(raw.x, raw.y)\n    }\n\n    pub fn raw_slice(slice: &[Point]) -> *const ll::SDL_Point {\n        unsafe {\n            mem::transmute(slice.as_ptr())\n        }\n    }\n\n    pub fn raw(&self) -> *const ll::SDL_Point {\n        &self.raw\n    }\n\n    /// Returns a new point by shifting this point's coordinates by the given\n    /// x and y values.\n    pub fn offset(&self, x: i32, y: i32) -> Point {\n        let x = match self.raw.x.checked_add(x) {\n            Some(val) => val,\n            None => {\n                if x < 0 {\n                    min_int_value()\n                } else {\n                    max_int_value() as i32\n                }\n            }\n        };\n        let y = match self.raw.y.checked_add(y) {\n            Some(val) => val,\n            None => {\n                if y < 0 {\n                    min_int_value()\n                } else {\n                    max_int_value() as i32\n                }\n            }\n        };\n        Point::new(x, y)\n    }\n\n    /// Returns a new point by multiplying this point's coordinates by the\n    /// given scale factor.\n    pub fn scale(&self, f: i32) -> Point {\n        Point::new(clamped_mul(self.raw.x, f),\n                   clamped_mul(self.raw.y, f))\n    }\n\n    /// Returns the x-coordinate of this point.\n    pub fn x(&self) -> i32 {\n        self.raw.x\n    }\n\n    /// Returns the y-coordinate of this point.\n    pub fn y(&self) -> i32 {\n        self.raw.y\n    }\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, rhs: Point) -> Point {\n        self.offset(rhs.x(), rhs.y())\n    }\n}\n\nimpl Neg for Point {\n    type Output = Point;\n\n    fn neg(self) -> Point {\n        Point::new(-self.x(), -self.y())\n    }\n}\n\nimpl Sub for Point {\n    type Output = Point;\n\n    fn sub(self, rhs: Point) -> Point {\n        self.offset(-rhs.x(), -rhs.y())\n    }\n}\n\nimpl Mul<i32> for Point {\n    type Output = Point;\n\n    fn mul(self, rhs: i32) -> Point {\n        self.scale(rhs)\n    }\n}\n\nimpl Div<i32> for Point {\n    type Output = Point;\n\n    fn div(self, rhs: i32) -> Point {\n        Point::new(self.x() / rhs, self.y() / rhs)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::{Rect, Point, max_int_value, min_int_value};\n\n    /// Used to compare \"literal\" (unclamped) rect values.\n    fn tuple(x: i32, y: i32, w: u32, h: u32) -> (i32, i32, u32, u32) {\n        (x, y, w, h)\n    }\n\n    #[test]\n    fn enclose_points_valid() {\n        assert_eq!(\n            Some(tuple(2, 4, 4, 6)),\n            Rect::from_enclose_points(\n                &[Point::new(2, 4), Point::new(5,9)],\n                None\n            ).map(|r| r.into())\n        );\n    }\n\n    #[test]\n    fn enclose_points_outside_clip_rect() {\n        assert_eq!(\n            Rect::from_enclose_points(\n                &[Point::new(0, 0), Point::new(10,10)],\n                Some(Rect::new(3, 3, 1, 1))),\n            None\n        );\n    }\n\n    #[test]\n    fn enclose_points_max_values() {\n        // Try to enclose the top-left-most and bottom-right-most points.\n        assert_eq!(\n            Some(tuple(\n                min_int_value(), min_int_value(),\n                max_int_value(), max_int_value()\n            )),\n            Rect::from_enclose_points(\n                &[Point::new(i32::min_value(), i32::min_value()),\n                Point::new(i32::max_value(), i32::max_value())], None\n            ).map(|r| r.into())\n        );\n    }\n\n    #[test]\n    fn has_intersection() {\n        let rect = Rect::new(0, 0, 10, 10);\n        assert!(rect.has_intersection(Rect::new(9, 9, 10, 10)));\n        // edge\n        assert!(! rect.has_intersection(Rect::new(10, 10, 10, 10)));\n        // out\n        assert!(! rect.has_intersection(Rect::new(11, 11, 10, 10)));\n    }\n\n    #[test]\n    fn intersection() {\n        let rect = Rect::new(0, 0, 10, 10);\n        assert_eq!(\n            rect & Rect::new(9, 9, 10, 10),\n            Some(Rect::new(9, 9, 1, 1))\n        );\n        assert_eq!(\n            rect & Rect::new(11, 11, 10, 10),\n            None\n        );\n    }\n\n    #[test]\n    fn union() {\n        assert_eq!(\n            Rect::new(0, 0, 1, 1) | Rect::new(9, 9, 1, 1),\n            Rect::new(0, 0, 10, 10)\n        );\n    }\n\n    #[test]\n    fn intersect_line() {\n        assert_eq!(\n            Rect::new(1, 1, 5, 5).intersect_line(\n                Point::new(0, 0), Point::new(10, 10)\n            ),\n            Some((Point::new(1, 1), Point::new(5, 5)))\n        );\n    }\n\n    #[test]\n    fn clamp_size_zero() {\n        assert_eq!(\n            tuple(0, 0, 1, 1),\n            Rect::new(0, 0, 0, 0).into()\n        );\n    }\n\n    #[test]\n    fn clamp_position_min() {\n        assert_eq!(\n            tuple(min_int_value(), min_int_value(), 1, 1),\n            Rect::new(i32::min_value(), i32::min_value(), 1, 1).into()\n        );\n    }\n\n    #[test]\n    fn clamp_size_max() {\n        assert_eq!(\n            tuple(0, 0, max_int_value(), max_int_value()),\n            Rect::new(0, 0, max_int_value() + 1, max_int_value() + 1).into()\n        );\n    }\n\n    #[test]\n    fn clamp_i32_max() {\n        assert_eq!(\n            tuple(0, 0, max_int_value(), max_int_value()),\n            Rect::new(\n                0, 0, i32::max_value() as u32, i32::max_value() as u32\n            ).into()\n        )\n    }\n\n    #[test]\n    fn clamp_position_max() {\n        assert_eq!(\n            tuple(max_int_value() as i32, max_int_value() as i32, 1, 1),\n            Rect::new(\n                max_int_value() as i32 + 1, max_int_value() as i32 + 1, 1, 1\n            ).into()\n        );\n    }\n\n    #[test]\n    fn rect_into() {\n        let test: (i32, i32, u32, u32) = (-11, 5, 50, 20);\n        assert_eq!(\n            test,\n            Rect::new(-11, 5, 50, 20).into()\n        );\n    }\n\n    #[test]\n    fn rect_from() {\n        assert_eq!(\n            Rect::from((-11, 5, 50, 20)),\n            Rect::new(-11, 5, 50, 20)\n        );\n    }\n\n    #[test]\n    fn point_into() {\n        let test: (i32, i32) = (-11, 5);\n        assert_eq!(\n            test,\n            Point::new(-11, 5).into()\n        );\n    }\n\n    #[test]\n    fn point_from() {\n        let test: (i32, i32) = (-11, 5);\n        assert_eq!(\n            test,\n            Point::new(-11, 5).into()\n        );\n    }\n\n    #[test]\n    fn point_add() {\n        assert_eq!(\n            Point::new(-5, 7),\n            Point::new(-11, 5) + Point::new(6, 2)\n        );\n    }\n\n    #[test]\n    fn point_sub() {\n        assert_eq!(\n            Point::new(-17, 3),\n            Point::new(-11, 5) - Point::new(6, 2)\n        );\n    }\n\n    #[test]\n    fn point_mul() {\n        assert_eq!(\n            Point::new(-33, 15),\n            Point::new(-11, 5) * 3\n        );\n    }\n\n    #[test]\n    fn point_mul_clamp() {\n        assert_eq!(\n            Point::new(0x7fffffff, -0x7fffffff),\n            Point::new(-1000000, 5000000) * -3000000\n        );\n    }\n\n    #[test]\n    fn point_div() {\n        assert_eq!(\n            Point::new(-3, 1),\n            Point::new(-11, 5) / 3\n        );\n    }\n }\n","use std::ffi::CString;\nuse std::io;\nuse std::path::Path;\nuse std::marker::PhantomData;\nuse libc::{c_void, c_int, size_t, c_char};\nuse get_error;\n\nuse sys::rwops as ll;\n\n/// A structure that provides an abstract interface to stream I/O.\npub struct RWops<'a> {\n    raw: *mut ll::SDL_RWops,\n    _marker: PhantomData<&'a ()>\n}\n\nimpl<'a> RWops<'a> {\n    pub unsafe fn raw(&self) -> *mut ll::SDL_RWops { self.raw }\n\n    pub unsafe fn from_ll<'b>(raw: *mut ll::SDL_RWops) -> RWops<'b> {\n        RWops {\n            raw: raw,\n            _marker: PhantomData\n        }\n    }\n\n    /// Creates an SDL file stream.\n    pub fn from_file<P: AsRef<Path>>(path: P, mode: &str) -> Result<RWops <'static>, String> {\n        let raw = unsafe {\n            let path_c = CString::new(path.as_ref().to_str().unwrap()).unwrap();\n            let mode_c = CString::new(mode).unwrap();\n            ll::SDL_RWFromFile(path_c.as_ptr() as *const c_char, mode_c.as_ptr() as *const c_char)\n        };\n\n        if raw.is_null() {\n            Err(get_error())\n        } else {\n            Ok(RWops {\n                raw: raw,\n                _marker: PhantomData\n            })\n        }\n    }\n\n    /// Prepares a read-only memory buffer for use with `RWops`.\n    ///\n    /// This method can only fail if the buffer size is zero.\n    pub fn from_bytes(buf: &'a [u8]) -> Result<RWops <'a>, String> {\n        let raw = unsafe {\n            ll::SDL_RWFromConstMem(buf.as_ptr() as *const c_void, buf.len() as c_int)\n        };\n\n        if raw.is_null() {\n            Err(get_error())\n        } else {\n            Ok(RWops {\n                raw: raw,\n                _marker: PhantomData\n            })\n        }\n    }\n\n    /// Reads a `Read` object into a buffer and then passes it to `RWops.from_bytes`.\n    ///\n    /// The buffer must be provided to this function and must live as long as the\n    /// `RWops`, but the `RWops` does not take ownership of it.\n    pub fn from_read<T>(r: &mut T, buffer: &'a mut Vec<u8>) -> Result<RWops<'a>, String>\n        where T: io::Read + Sized {\n        match r.read_to_end(buffer) {\n            Ok(_size) => RWops::from_bytes(buffer),\n            Err(ioerror) => {\n                let msg = format!(\"IO error: {}\", ioerror);\n                Err(msg)\n            }\n        }\n    }\n\n    /// Prepares a read-write memory buffer for use with `RWops`.\n    ///\n    /// This method can only fail if the buffer size is zero.\n    pub fn from_bytes_mut(buf: &'a mut [u8]) -> Result<RWops <'a>, String> {\n        let raw = unsafe {\n            ll::SDL_RWFromMem(buf.as_ptr() as *mut c_void, buf.len() as c_int)\n        };\n\n        if raw.is_null() {\n            Err(get_error())\n        } else {\n            Ok(RWops {\n                raw: raw,\n                _marker: PhantomData\n            })\n        }\n    }\n\n    /// Gets the stream's total size in bytes.\n    ///\n    /// Returns `None` if the stream size can't be determined\n    /// (either because it doesn't make sense for the stream type, or there was an error).\n    pub fn len(&self) -> Option<usize> {\n        let result = unsafe { ((*self.raw).size)(self.raw) };\n\n        match result {\n            -1 => None,\n            v => Some(v as usize)\n        }\n    }\n}\n\nimpl<'a> Drop for RWops<'a> {\n    fn drop(&mut self) {\n        let ret = unsafe { ((*self.raw).close)(self.raw) };\n        if ret != 0 {\n            panic!(get_error());\n        }\n    }\n}\n\nimpl<'a> io::Read for RWops<'a> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let out_len = buf.len() as size_t;\n        // FIXME: it's better to use as_mut_ptr().\n        // number of objects read, or 0 at error or end of file.\n        let ret = unsafe {\n            ((*self.raw).read)(self.raw, buf.as_ptr() as *mut c_void, 1, out_len)\n        };\n        Ok(ret as usize)\n    }\n}\n\nimpl<'a> io::Write for RWops<'a> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let in_len = buf.len() as size_t;\n        let ret = unsafe {\n            ((*self.raw).write)(self.raw, buf.as_ptr() as *const c_void, 1, in_len)\n        };\n        Ok(ret as usize)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl<'a> io::Seek for RWops<'a> {\n    fn seek(&mut self, pos: io::SeekFrom) -> io::Result<u64> {\n        // whence code is different from SeekStyle\n        let (whence, offset) = match pos {\n            io::SeekFrom::Start(pos) => (ll::RW_SEEK_SET, pos as i64),\n            io::SeekFrom::End(pos) => (ll::RW_SEEK_END, pos),\n            io::SeekFrom::Current(pos) => (ll::RW_SEEK_CUR, pos)\n        };\n        let ret = unsafe {\n            ((*self.raw).seek)(self.raw, offset, whence)\n        };\n        if ret == -1 {\n            Err(io::Error::last_os_error())\n        } else {\n            Ok(ret as u64)\n        }\n    }\n}\n","extern crate rand;\n\nuse num::FromPrimitive;\n\nuse sys::pixels as ll;\nuse libc;\n\nuse get_error;\n\npub struct Palette {\n    raw: *mut ll::SDL_Palette\n}\n\nimpl Palette {\n    #[inline]\n    /// Creates a new, uninitialized palette\n    pub fn new(mut capacity: usize) -> Result<Self, String> {\n        use common::*;\n\n        let ncolors = {\n            // This is kind of a hack. We have to cast twice because\n            // ncolors is a c_int, and validate_int only takes a u32.\n            // FIXME: Modify validate_int to make this unnecessary\n            let u32_max = u32::max_value() as usize;\n            if capacity > u32_max { capacity = u32_max; }\n\n            match validate_int(capacity as u32, \"capacity\") {\n                Ok(len) => len,\n                Err(e) => return Err(format!(\"{}\", e)),\n            }\n        };\n\n        let raw = unsafe { ll::SDL_AllocPalette(ncolors) };\n\n        if raw.is_null() {\n            Err(get_error())\n        } else {\n            Ok(Palette {\n                raw: raw,\n            })\n        }\n    }\n\n    /// Creates a palette from the provided colors\n    pub fn with_colors(colors: &[Color]) -> Result<Self, String> {\n        let pal = try!(Self::new(colors.len()));\n\n        // Already validated, so don't check again\n        let ncolors = colors.len() as ::libc::c_int;\n\n        let result = unsafe {\n            let mut raw_colors: Vec<ll::SDL_Color> = colors.iter()\n                .map(|color| color.raw())\n                .collect();\n\n            let pal_ptr = (&mut raw_colors[0]) as *mut ll::SDL_Color;\n\n            ll::SDL_SetPaletteColors(pal.raw, pal_ptr, 0, ncolors)\n        };\n\n        if result < 0 {\n            Err(get_error())\n        } else {\n            Ok(pal)\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        unsafe { (*self.raw).ncolors as usize }\n    }\n}\n\nimpl Drop for Palette {\n    fn drop(&mut self) {\n        unsafe { ll::SDL_FreePalette(self.raw); }\n    }\n}\n\nimpl_raw_accessors!((Palette, *mut ll::SDL_Palette));\n\n#[test]\nfn create_palette() {\n    let colors: Vec<_> = (0 .. 0xff).map(|u| {\n        Color::RGB(u, 0, 0xff - u)\n    }).collect();\n\n    let palette = Palette::with_colors(&colors).unwrap();\n\n    assert!(palette.len() == 255);\n}\n\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\npub struct Color {\n    pub r: u8,\n    pub g: u8,\n    pub b: u8,\n    pub a: u8\n}\n\nimpl Color {\n    #[inline]\n    #[allow(non_snake_case)]\n    pub fn RGB(r: u8, g: u8, b: u8) -> Color {\n        Color { r: r, g: g, b: b, a: 0xff }\n    }\n\n    #[inline]\n    #[allow(non_snake_case)]\n    pub fn RGBA(r: u8, g: u8, b: u8, a: u8) -> Color {\n        Color { r: r, g: g, b: b, a: a }\n    }\n\n    pub fn to_u32(&self, format: &PixelFormat) -> u32 {\n        unsafe { ll::SDL_MapRGBA(format.raw, self.r, self.g, self.b, self.a) }\n    }\n\n    pub fn from_u32(format: &PixelFormat, pixel: u32) -> Color {\n        let (mut r, mut g, mut b, mut a) = (0, 0, 0, 0);\n\n        unsafe {\n            ll::SDL_GetRGBA(pixel, format.raw, &mut r, &mut g, &mut b, &mut a)\n        };\n        Color::RGBA(r, g, b, a)\n    }\n\n    #[inline]\n    pub fn rgb(&self) -> (u8, u8, u8) {\n        (self.r, self.g, self.b)\n    }\n\n    #[inline]\n    pub fn rgba(&self) -> (u8, u8, u8, u8) {\n        (self.r, self.g, self.b, self.a)\n    }\n\n    // Implemented manually and kept private, because reasons\n    #[inline]\n    fn raw(&self) -> ll::SDL_Color {\n        ll::SDL_Color { r: self.r, g: self.g, b: self.b, a: self.a }\n    }\n}\n\nimpl Into<ll::SDL_Color> for Color {\n    fn into(self) -> ll::SDL_Color {\n        self.raw()\n    }\n}\n\nimpl From<ll::SDL_Color> for Color {\n    fn from(raw: ll::SDL_Color) -> Color {\n        Color::RGBA(raw.r, raw.g, raw.b, raw.a)\n    }\n}\n\nimpl rand::Rand for Color {\n    fn rand<R: rand::Rng>(rng: &mut R) -> Color {\n        if rng.gen() { Color::RGBA(rng.gen(), rng.gen(), rng.gen(), rng.gen()) }\n        else { Color::RGB(rng.gen(), rng.gen(), rng.gen()) }\n    }\n}\n\npub struct PixelMasks {\n    /// Bits per pixel; usually 15, 16, or 32\n    pub bpp: u8,\n    /// The red mask\n    pub rmask: u32,\n    /// The green mask\n    pub gmask: u32,\n    /// The blue mask\n    pub bmask: u32,\n    /// The alpha mask\n    pub amask: u32\n}\n\npub struct PixelFormat {\n    raw: *mut ll::SDL_PixelFormat\n}\n\nimpl_raw_accessors!((PixelFormat, *mut ll::SDL_PixelFormat));\nimpl_raw_constructor!((PixelFormat, PixelFormat (raw: *mut ll::SDL_PixelFormat)));\n\n#[repr(i32)]\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\npub enum PixelFormatEnum {\n    Unknown = ll::SDL_PIXELFORMAT_UNKNOWN as i32,\n    Index1LSB = ll::SDL_PIXELFORMAT_INDEX1LSB as i32,\n    Index1MSB = ll::SDL_PIXELFORMAT_INDEX1MSB as i32,\n    Index4LSB = ll::SDL_PIXELFORMAT_INDEX4LSB as i32,\n    Index4MSB = ll::SDL_PIXELFORMAT_INDEX4MSB as i32,\n    Index8 = ll::SDL_PIXELFORMAT_INDEX8 as i32,\n    RGB332 = ll::SDL_PIXELFORMAT_RGB332 as i32,\n    RGB444 = ll::SDL_PIXELFORMAT_RGB444 as i32,\n    RGB555 = ll::SDL_PIXELFORMAT_RGB555 as i32,\n    BGR555 = ll::SDL_PIXELFORMAT_BGR555 as i32,\n    ARGB4444 = ll::SDL_PIXELFORMAT_ARGB4444 as i32,\n    RGBA4444 = ll::SDL_PIXELFORMAT_RGBA4444 as i32,\n    ABGR4444 = ll::SDL_PIXELFORMAT_ABGR4444 as i32,\n    BGRA4444 = ll::SDL_PIXELFORMAT_BGRA4444 as i32,\n    ARGB1555 = ll::SDL_PIXELFORMAT_ARGB1555 as i32,\n    RGBA5551 = ll::SDL_PIXELFORMAT_RGBA5551 as i32,\n    ABGR1555 = ll::SDL_PIXELFORMAT_ABGR1555 as i32,\n    BGRA5551 = ll::SDL_PIXELFORMAT_BGRA5551 as i32,\n    RGB565 = ll::SDL_PIXELFORMAT_RGB565 as i32,\n    BGR565 = ll::SDL_PIXELFORMAT_BGR565 as i32,\n    RGB24 = ll::SDL_PIXELFORMAT_RGB24 as i32,\n    BGR24 = ll::SDL_PIXELFORMAT_BGR24 as i32,\n    RGB888 = ll::SDL_PIXELFORMAT_RGB888 as i32,\n    RGBX8888 = ll::SDL_PIXELFORMAT_RGBX8888 as i32,\n    BGR888 = ll::SDL_PIXELFORMAT_BGR888 as i32,\n    BGRX8888 = ll::SDL_PIXELFORMAT_BGRX8888 as i32,\n    ARGB8888 = ll::SDL_PIXELFORMAT_ARGB8888 as i32,\n    RGBA8888 = ll::SDL_PIXELFORMAT_RGBA8888 as i32,\n    ABGR8888 = ll::SDL_PIXELFORMAT_ABGR8888 as i32,\n    BGRA8888 = ll::SDL_PIXELFORMAT_BGRA8888 as i32,\n    ARGB2101010 = ll::SDL_PIXELFORMAT_ARGB2101010 as i32,\n    YV12 = ll::SDL_PIXELFORMAT_YV12 as i32,\n    IYUV = ll::SDL_PIXELFORMAT_IYUV as i32,\n    YUY2 = ll::SDL_PIXELFORMAT_YUY2 as i32,\n    UYVY = ll::SDL_PIXELFORMAT_UYVY as i32,\n    YVYU = ll::SDL_PIXELFORMAT_YVYU as i32\n}\n\nimpl PixelFormatEnum {\n    pub fn from_masks(masks: PixelMasks) -> PixelFormatEnum {\n        unsafe {\n            let format = ll::SDL_MasksToPixelFormatEnum(masks.bpp as i32, masks.rmask, masks.gmask, masks.bmask, masks.amask);\n            PixelFormatEnum::from_u64(format as u64).unwrap()\n        }\n    }\n\n    pub fn into_masks(self) -> Result<PixelMasks, String> {\n        let format: u32 = self as u32;\n        let mut bpp = 0;\n        let mut rmask = 0;\n        let mut gmask = 0;\n        let mut bmask = 0;\n        let mut amask = 0;\n        let result = unsafe {\n            ll::SDL_PixelFormatEnumToMasks(format, &mut bpp, &mut rmask, &mut gmask, &mut bmask, &mut amask)\n        };\n        if result == 0 {\n            // SDL_FALSE\n            Err(get_error())\n        } else {\n            Ok(PixelMasks {\n                bpp: bpp as u8,\n                rmask: rmask,\n                gmask: gmask,\n                bmask: bmask,\n                amask: amask\n            })\n        }\n    }\n\n    /// Calculates the total byte size of an image buffer, given its pitch\n    /// and height.\n    pub fn byte_size_from_pitch_and_height(&self, pitch: usize, height: usize) -> usize {\n        match *self {\n            PixelFormatEnum::YV12 | PixelFormatEnum::IYUV => {\n                // YUV is 4:2:0.\n                // `pitch` is the width of the Y component, and\n                // `height` is the height of the Y component.\n                // U and V have half the width and height of Y.\n                pitch * height + 2 * (pitch / 2 * height / 2)\n            },\n            _ => pitch * height\n        }\n    }\n\n    pub fn byte_size_of_pixels(&self, num_of_pixels: usize) -> usize {\n        match *self {\n            PixelFormatEnum::RGB332\n                => num_of_pixels,\n            PixelFormatEnum::RGB444 | PixelFormatEnum::RGB555 |\n            PixelFormatEnum::BGR555 | PixelFormatEnum::ARGB4444 |\n            PixelFormatEnum::RGBA4444 | PixelFormatEnum::ABGR4444 |\n            PixelFormatEnum::BGRA4444 | PixelFormatEnum::ARGB1555 |\n            PixelFormatEnum::RGBA5551 | PixelFormatEnum::ABGR1555 |\n            PixelFormatEnum::BGRA5551 | PixelFormatEnum::RGB565 |\n            PixelFormatEnum::BGR565\n                => num_of_pixels * 2,\n            PixelFormatEnum::RGB24 | PixelFormatEnum::BGR24\n                => num_of_pixels * 3,\n            PixelFormatEnum::RGB888 | PixelFormatEnum::RGBX8888 |\n            PixelFormatEnum::BGR888 | PixelFormatEnum::BGRX8888 |\n            PixelFormatEnum::ARGB8888 | PixelFormatEnum::RGBA8888 |\n            PixelFormatEnum::ABGR8888 | PixelFormatEnum::BGRA8888 |\n            PixelFormatEnum::ARGB2101010\n                => num_of_pixels * 4,\n            // YUV formats\n            // FIXME: rounding error here?\n            PixelFormatEnum::YV12 | PixelFormatEnum::IYUV\n                => num_of_pixels / 2 * 3,\n            PixelFormatEnum::YUY2 | PixelFormatEnum::UYVY |\n            PixelFormatEnum::YVYU\n                => num_of_pixels * 2,\n            // Unsupported formats\n            PixelFormatEnum::Index8\n                => num_of_pixels,\n            PixelFormatEnum::Unknown | PixelFormatEnum::Index1LSB |\n            PixelFormatEnum::Index1MSB | PixelFormatEnum::Index4LSB |\n            PixelFormatEnum::Index4MSB\n                => panic!(\"not supported format: {:?}\", *self),\n        }\n    }\n\n    pub fn byte_size_per_pixel(&self) -> usize {\n        match *self {\n            PixelFormatEnum::RGB332\n                => 1,\n            PixelFormatEnum::RGB444 | PixelFormatEnum::RGB555 |\n            PixelFormatEnum::BGR555 | PixelFormatEnum::ARGB4444 |\n            PixelFormatEnum::RGBA4444 | PixelFormatEnum::ABGR4444 |\n            PixelFormatEnum::BGRA4444 | PixelFormatEnum::ARGB1555 |\n            PixelFormatEnum::RGBA5551 | PixelFormatEnum::ABGR1555 |\n            PixelFormatEnum::BGRA5551 | PixelFormatEnum::RGB565 |\n            PixelFormatEnum::BGR565\n                => 2,\n            PixelFormatEnum::RGB24 | PixelFormatEnum::BGR24\n                => 3,\n            PixelFormatEnum::RGB888 | PixelFormatEnum::RGBX8888 |\n            PixelFormatEnum::BGR888 | PixelFormatEnum::BGRX8888 |\n            PixelFormatEnum::ARGB8888 | PixelFormatEnum::RGBA8888 |\n            PixelFormatEnum::ABGR8888 | PixelFormatEnum::BGRA8888 |\n            PixelFormatEnum::ARGB2101010\n                => 4,\n            // YUV formats\n            PixelFormatEnum::YV12 | PixelFormatEnum::IYUV\n                => 2,\n            PixelFormatEnum::YUY2 | PixelFormatEnum::UYVY |\n            PixelFormatEnum::YVYU\n                => 2,\n            // Unsupported formats\n            PixelFormatEnum::Index8\n                => 1,\n            PixelFormatEnum::Unknown | PixelFormatEnum::Index1LSB |\n            PixelFormatEnum::Index1MSB | PixelFormatEnum::Index4LSB |\n            PixelFormatEnum::Index4MSB\n                => panic!(\"not supported format: {:?}\", *self),\n        }\n    }\n\n    pub fn supports_alpha(&self) -> bool {\n        use ::pixels::PixelFormatEnum::*;\n        match *self {\n            ARGB4444 | ARGB1555 | ARGB8888 | ARGB2101010 |\n            ABGR4444 | ABGR1555 | ABGR8888 |\n            BGRA4444 | BGRA5551 | BGRA8888 |\n            RGBA4444 | RGBA5551 | RGBA8888 => true,\n            _ => false\n        }\n    }\n}\n\nimpl Into<ll::SDL_PixelFormatEnum> for PixelFormatEnum {\n    fn into(self) -> ll::SDL_PixelFormatEnum {\n        self as libc::uint32_t\n    }\n}\n\nimpl From<PixelFormat> for PixelFormatEnum {\n    fn from(pf: PixelFormat) -> PixelFormatEnum {\n        unsafe {\n            let ref sdl_pf = *pf.raw;\n            match PixelFormatEnum::from_u64(sdl_pf.format as u64) {\n                Some(pfe) => pfe,\n                None => panic!(\"Unknown pixel format: {:?}\", sdl_pf.format)\n            }\n        }\n    }\n}\n\nimpl FromPrimitive for PixelFormatEnum {\n    fn from_i64(n: i64) -> Option<PixelFormatEnum> {\n        use self::PixelFormatEnum::*;\n\n        Some( match n as ll::SDL_PixelFormatEnum {\n            ll::SDL_PIXELFORMAT_UNKNOWN     => Unknown,\n            ll::SDL_PIXELFORMAT_INDEX1LSB   => Index1LSB,\n            ll::SDL_PIXELFORMAT_INDEX1MSB   => Index1MSB,\n            ll::SDL_PIXELFORMAT_INDEX4LSB   => Index4LSB,\n            ll::SDL_PIXELFORMAT_INDEX4MSB   => Index4MSB,\n            ll::SDL_PIXELFORMAT_INDEX8      => Index8,\n            ll::SDL_PIXELFORMAT_RGB332      => RGB332,\n            ll::SDL_PIXELFORMAT_RGB444      => RGB444,\n            ll::SDL_PIXELFORMAT_RGB555      => RGB555,\n            ll::SDL_PIXELFORMAT_BGR555      => BGR555,\n            ll::SDL_PIXELFORMAT_ARGB4444    => ARGB4444,\n            ll::SDL_PIXELFORMAT_RGBA4444    => RGBA4444,\n            ll::SDL_PIXELFORMAT_ABGR4444    => ABGR4444,\n            ll::SDL_PIXELFORMAT_BGRA4444    => BGRA4444,\n            ll::SDL_PIXELFORMAT_ARGB1555    => ARGB1555,\n            ll::SDL_PIXELFORMAT_RGBA5551    => RGBA5551,\n            ll::SDL_PIXELFORMAT_ABGR1555    => ABGR1555,\n            ll::SDL_PIXELFORMAT_BGRA5551    => BGRA5551,\n            ll::SDL_PIXELFORMAT_RGB565      => RGB565,\n            ll::SDL_PIXELFORMAT_BGR565      => BGR565,\n            ll::SDL_PIXELFORMAT_RGB24       => RGB24,\n            ll::SDL_PIXELFORMAT_BGR24       => BGR24,\n            ll::SDL_PIXELFORMAT_RGB888      => RGB888,\n            ll::SDL_PIXELFORMAT_RGBX8888    => RGBX8888,\n            ll::SDL_PIXELFORMAT_BGR888      => BGR888,\n            ll::SDL_PIXELFORMAT_BGRX8888    => BGRX8888,\n            ll::SDL_PIXELFORMAT_ARGB8888    => ARGB8888,\n            ll::SDL_PIXELFORMAT_RGBA8888    => RGBA8888,\n            ll::SDL_PIXELFORMAT_ABGR8888    => ABGR8888,\n            ll::SDL_PIXELFORMAT_BGRA8888    => BGRA8888,\n            ll::SDL_PIXELFORMAT_ARGB2101010 => ARGB2101010,\n            ll::SDL_PIXELFORMAT_YV12        => YV12,\n            ll::SDL_PIXELFORMAT_IYUV        => IYUV,\n            ll::SDL_PIXELFORMAT_YUY2        => YUY2,\n            ll::SDL_PIXELFORMAT_UYVY        => UYVY,\n            ll::SDL_PIXELFORMAT_YVYU        => YVYU,\n            _                               => return None,\n        })\n    }\n\n    fn from_u64(n: u64) -> Option<PixelFormatEnum> { FromPrimitive::from_i64(n as i64) }\n}\n\n\n// Just test a round-trip conversion from PixelFormat to\n// PixelFormatEnum and back.\n#[test]\nfn test_pixel_format_enum() {\n    let pixel_formats = vec![\n        PixelFormatEnum::RGB332,\n        PixelFormatEnum::RGB444, PixelFormatEnum::RGB555,\n        PixelFormatEnum::BGR555, PixelFormatEnum::ARGB4444,\n        PixelFormatEnum::RGBA4444, PixelFormatEnum::ABGR4444,\n        PixelFormatEnum::BGRA4444, PixelFormatEnum::ARGB1555,\n        PixelFormatEnum::RGBA5551, PixelFormatEnum::ABGR1555,\n        PixelFormatEnum::BGRA5551, PixelFormatEnum::RGB565,\n        PixelFormatEnum::BGR565,\n        PixelFormatEnum::RGB24, PixelFormatEnum::BGR24,\n        PixelFormatEnum::RGB888, PixelFormatEnum::RGBX8888,\n        PixelFormatEnum::BGR888, PixelFormatEnum::BGRX8888,\n        PixelFormatEnum::ARGB8888, PixelFormatEnum::RGBA8888,\n        PixelFormatEnum::ABGR8888, PixelFormatEnum::BGRA8888,\n        PixelFormatEnum::ARGB2101010,\n        PixelFormatEnum::YV12, PixelFormatEnum::IYUV,\n        PixelFormatEnum::YUY2, PixelFormatEnum::UYVY,\n        PixelFormatEnum::YVYU,\n        PixelFormatEnum::Index8,\n        // These don't seem to be supported;\n        // the round-trip \n        //PixelFormatEnum::Unknown, PixelFormatEnum::Index1LSB,\n        //PixelFormatEnum::Index1MSB, PixelFormatEnum::Index4LSB,\n        //PixelFormatEnum::Index4MSB\n    ];\n\n    \n    let _sdl_context = ::sdl::init().unwrap();\n    for format in pixel_formats {\n        // If we don't support making a surface of a specific format,\n        // that's fine, just keep going the best we can.\n        if let Ok(surf) = super::surface::Surface::new(1, 1, format) {\n            let surf_format = surf.pixel_format();\n            assert_eq!(PixelFormatEnum::from(surf_format), format);\n        }\n    }\n}\n",null,null,null,null,"use libc::{c_int, c_float, uint32_t, c_char};\nuse std::ffi::{CStr, CString, NulError};\nuse std::{mem, ptr, fmt};\nuse std::rc::Rc;\nuse std::error::Error;\nuse std::ops::{Deref, DerefMut};\n\nuse rect::Rect;\nuse render::CanvasBuilder;\nuse surface::SurfaceRef;\nuse pixels::PixelFormatEnum;\nuse VideoSubsystem;\nuse EventPump;\nuse num::FromPrimitive;\nuse common::{validate_int, IntegerOrSdlError};\n\nuse get_error;\n\nuse sys::video as ll;\n\n\npub struct WindowSurfaceRef<'a>(&'a mut SurfaceRef, &'a Window);\n\nimpl<'a> Deref for WindowSurfaceRef<'a> {\n    type Target = SurfaceRef;\n\n    #[inline]\n    fn deref(&self) -> &SurfaceRef {\n        &self.0\n    }\n}\n\nimpl<'a> DerefMut for WindowSurfaceRef<'a> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut SurfaceRef {\n        &mut self.0\n    }\n}\n\nimpl<'a> WindowSurfaceRef<'a> {\n    /// Updates the change made to the inner Surface to the Window it was created from.\n    ///\n    /// This would effectively be the theorical equivalent of `present` from a Canvas.\n    pub fn update_window(&self) -> Result<(), String> {\n        unsafe {\n            if ll::SDL_UpdateWindowSurface(self.1.context.raw) == 0 {\n                Ok(())\n            } else {\n                Err(get_error())\n            }\n        }\n    }\n\n    /// Same as `update_window`, but only update the parts included in `rects` to the Window it was\n    /// created from.\n    pub fn update_window_rects(&self, rects: &[Rect]) -> Result<(), String> {\n        unsafe {\n            if ll::SDL_UpdateWindowSurfaceRects(self.1.context.raw, Rect::raw_slice(rects), rects.len() as c_int) == 0 {\n                Ok(())\n            } else {\n                Err(get_error())\n            }\n        }\n    }\n\n    /// Gives up this WindowSurfaceRef, allowing to use the window freely again. Before being\n    /// destroyed, calls `update_window` one last time.\n    ///\n    /// If you don't want to `update_window` one last time, simply Drop this struct. However\n    /// beware, since the Surface will still be in the state you left it the next time you will\n    /// call `window.surface()` again.\n    pub fn finish(self) -> Result<(), String> {\n        self.update_window()\n    }\n}\n\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\npub enum GLProfile {\n    /// OpenGL core profile - deprecated functions are disabled\n    Core,\n    /// OpenGL compatibility profile - deprecated functions are allowed\n    Compatibility,\n    /// OpenGL ES profile - only a subset of the base OpenGL functionality is available\n    GLES,\n    /// Unknown profile - SDL will tend to return 0 if you ask when no particular profile\n    /// has been defined or requested.\n    Unknown(i32)\n}\n\ntrait GLAttrTypeUtil {\n    fn to_gl_value(self) -> i32;\n    fn from_gl_value(value: i32) -> Self;\n}\n\nimpl GLAttrTypeUtil for u8 {\n    fn to_gl_value(self) -> i32 { self as i32 }\n    fn from_gl_value(value: i32) -> u8 { value as u8 }\n}\n\nimpl GLAttrTypeUtil for bool {\n    fn to_gl_value(self) -> i32 { if self { 1 } else { 0 } }\n    fn from_gl_value(value: i32) -> bool { value != 0 }\n}\n\nimpl GLAttrTypeUtil for GLProfile {\n    fn to_gl_value(self) -> i32 {\n        use self::GLProfile::*;\n\n        match self {\n            Unknown(i) => i,\n            Core => 1,\n            Compatibility => 2,\n            GLES => 4,\n        }\n    }\n    fn from_gl_value(value: i32) -> GLProfile {\n        use self::GLProfile::*;\n\n        match value {\n            1 => Core,\n            2 => Compatibility,\n            4 => GLES,\n            i => Unknown(i),\n        }\n    }\n}\n\nmacro_rules! attrs {\n    (\n        $(($attr_name:ident, $set_property:ident, $get_property:ident, $t:ty, $doc:expr)),*\n    ) => (\n\n        $(\n        #[doc = \"**Sets** the attribute: \"]\n        #[doc = $doc]\n        #[inline]\n        pub fn $set_property(&self, value: $t) {\n            gl_set_attribute!($attr_name, value.to_gl_value());\n        }\n\n        #[doc = \"**Gets** the attribute: \"]\n        #[doc = $doc]\n        #[inline]\n        pub fn $get_property(&self) -> $t {\n            let value = gl_get_attribute!($attr_name);\n            GLAttrTypeUtil::from_gl_value(value)\n        }\n        )*\n    );\n}\n\n/// OpenGL context getters and setters\n///\n/// # Example\n/// ```no_run\n/// use sdl2::video::GLProfile;\n///\n/// let sdl_context = sdl2::init().unwrap();\n/// let video_subsystem = sdl_context.video().unwrap();\n/// let gl_attr = video_subsystem.gl_attr();\n///\n/// // Don't use deprecated OpenGL functions\n/// gl_attr.set_context_profile(GLProfile::Core);\n///\n/// // Set the context into debug mode\n/// gl_attr.set_context_flags().debug().set();\n///\n/// // Set the OpenGL context version (OpenGL 3.2)\n/// gl_attr.set_context_version(3, 2);\n///\n/// // Enable anti-aliasing\n/// gl_attr.set_multisample_buffers(1);\n/// gl_attr.set_multisample_samples(4);\n///\n/// let window = video_subsystem.window(\"rust-sdl2 demo: Video\", 800, 600).opengl().build().unwrap();\n///\n/// // Yes, we're still using the Core profile\n/// assert_eq!(gl_attr.context_profile(), GLProfile::Core);\n/// // ... and we're still using OpenGL 3.2\n/// assert_eq!(gl_attr.context_version(), (3, 2));\n/// ```\npub mod gl_attr {\n    use get_error;\n    use sys::video as ll;\n    use std::marker::PhantomData;\n    use super::{GLProfile, GLAttrTypeUtil};\n\n    /// OpenGL context getters and setters. Obtain with `VideoSubsystem::gl_attr()`.\n    pub struct GLAttr<'a> {\n        _marker: PhantomData<&'a ::VideoSubsystem>\n    }\n\n    impl ::VideoSubsystem {\n        /// Obtains access to the OpenGL window attributes.\n        pub fn gl_attr(&self) -> GLAttr {\n            GLAttr {\n                _marker: PhantomData\n            }\n        }\n    }\n\n    macro_rules! gl_set_attribute {\n        ($attr:ident, $value:expr) => ({\n            let result = unsafe {\n                ll::SDL_GL_SetAttribute(ll::SDL_GLattr::$attr, $value)\n            };\n\n            if result != 0 {\n                // Panic and print the attribute that failed.\n                panic!(\"couldn't set attribute {}: {}\", stringify!($attr), get_error());\n            }\n        })\n    }\n\n    macro_rules! gl_get_attribute {\n        ($attr:ident) => ({\n            let mut value = 0;\n            let result = unsafe {\n                ll::SDL_GL_GetAttribute(ll::SDL_GLattr::$attr, &mut value)\n            };\n            if result != 0 {\n                // Panic and print the attribute that failed.\n                panic!(\"couldn't get attribute {}: {}\", stringify!($attr), get_error());\n            }\n            value\n        })\n    }\n\n    impl<'a> GLAttr<'a> {\n\n    // Note: Wish I could avoid the redundancy of set_property and property (without namespacing into new modules),\n    // but Rust's `concat_idents!` macro isn't stable.\n    attrs! {\n        (SDL_GL_RED_SIZE, set_red_size, red_size, u8,\n            \"the minimum number of bits for the red channel of the color buffer; defaults to 3\"),\n\n        (SDL_GL_GREEN_SIZE, set_green_size, green_size, u8,\n            \"the minimum number of bits for the green channel of the color buffer; defaults to 3\"),\n\n        (SDL_GL_BLUE_SIZE, set_blue_size, blue_size, u8,\n            \"the minimum number of bits for the blue channel of the color buffer; defaults to 2\"),\n\n        (SDL_GL_ALPHA_SIZE, set_alpha_size, alpha_size, u8,\n            \"the minimum number of bits for the alpha channel of the color buffer; defaults to 0\"),\n\n        (SDL_GL_BUFFER_SIZE, set_buffer_size, buffer_size, u8,\n            \"the minimum number of bits for frame buffer size; defaults to 0\"),\n\n        (SDL_GL_DOUBLEBUFFER, set_double_buffer, double_buffer, bool,\n            \"whether the output is single or double buffered; defaults to double buffering on\"),\n\n        (SDL_GL_DEPTH_SIZE, set_depth_size, depth_size, u8,\n            \"the minimum number of bits in the depth buffer; defaults to 16\"),\n\n        (SDL_GL_STENCIL_SIZE, set_stencil_size, stencil_size, u8,\n            \"the minimum number of bits in the stencil buffer; defaults to 0\"),\n\n        (SDL_GL_ACCUM_RED_SIZE, set_accum_red_size, accum_red_size, u8,\n            \"the minimum number of bits for the red channel of the accumulation buffer; defaults to 0\"),\n\n        (SDL_GL_ACCUM_GREEN_SIZE, set_accum_green_size, accum_green_size, u8,\n            \"the minimum number of bits for the green channel of the accumulation buffer; defaults to 0\"),\n\n        (SDL_GL_ACCUM_BLUE_SIZE, set_accum_blue_size, accum_blue_size, u8,\n            \"the minimum number of bits for the blue channel of the accumulation buffer; defaults to 0\"),\n\n        (SDL_GL_ACCUM_ALPHA_SIZE, set_accum_alpha_size, accum_alpha_size, u8,\n            \"the minimum number of bits for the alpha channel of the accumulation buffer; defaults to 0\"),\n\n        (SDL_GL_STEREO, set_stereo, stereo, bool,\n            \"whether the output is stereo 3D; defaults to off\"),\n\n        (SDL_GL_MULTISAMPLEBUFFERS, set_multisample_buffers, multisample_buffers, u8,\n            \"the number of buffers used for multisample anti-aliasing; defaults to 0\"),\n\n        (SDL_GL_MULTISAMPLESAMPLES, set_multisample_samples, multisample_samples, u8,\n            \"the number of samples used around the current pixel used for multisample anti-aliasing; defaults to 0\"),\n\n        (SDL_GL_ACCELERATED_VISUAL, set_accelerated_visual, accelerated_visual, bool,\n            \"whether to require hardware acceleration; false to force software rendering; defaults to allow either\"),\n\n        (SDL_GL_CONTEXT_MAJOR_VERSION, set_context_major_version, context_major_version, u8,\n            \"OpenGL context major version\"),\n\n        (SDL_GL_CONTEXT_MINOR_VERSION, set_context_minor_version, context_minor_version, u8,\n            \"OpenGL context minor version\"),\n\n        (SDL_GL_CONTEXT_PROFILE_MASK, set_context_profile, context_profile, GLProfile,\n            \"type of GL context (Core, Compatibility, ES)\"),\n\n        (SDL_GL_SHARE_WITH_CURRENT_CONTEXT, set_share_with_current_context, share_with_current_context, bool,\n            \"OpenGL context sharing; defaults to false\"),\n\n        (SDL_GL_FRAMEBUFFER_SRGB_CAPABLE, set_framebuffer_srgb_compatible, framebuffer_srgb_compatible, bool,\n            \"requests sRGB capable visual; defaults to false (>= SDL 2.0.1)\")\n    }\n\n    /// **Sets** the OpenGL context major and minor versions.\n    #[inline]\n    pub fn set_context_version(&self, major: u8, minor: u8) {\n        self.set_context_major_version(major);\n        self.set_context_minor_version(minor);\n    }\n\n    /// **Gets** the OpenGL context major and minor versions as a tuple.\n    #[inline]\n    pub fn context_version(&self) -> (u8, u8) {\n        (self.context_major_version(), self.context_minor_version())\n    }\n\n    }\n\n    /// The type that allows you to build a OpenGL context configuration.\n    pub struct ContextFlagsBuilder<'a> {\n        flags: i32,\n        _marker: PhantomData<&'a ::VideoSubsystem>\n    }\n\n    impl<'a> ContextFlagsBuilder<'a> {\n        /// Finishes the builder and applies the GL context flags to the GL context.\n        #[inline]\n        pub fn set(&self) {\n            gl_set_attribute!(SDL_GL_CONTEXT_FLAGS, self.flags);\n        }\n\n        /// Sets the context into \"debug\" mode.\n        #[inline]\n        pub fn debug(&mut self) -> &mut ContextFlagsBuilder<'a> {\n            self.flags |= 0x0001;\n            self\n        }\n\n        /// Sets the context into \"forward compatible\" mode.\n        #[inline]\n        pub fn forward_compatible(&mut self) -> &mut ContextFlagsBuilder<'a> {\n            self.flags |= 0x0002;\n            self\n        }\n\n        #[inline]\n        pub fn robust_access(&mut self) -> &mut ContextFlagsBuilder<'a> {\n            self.flags |= 0x0004;\n            self\n        }\n\n        #[inline]\n        pub fn reset_isolation(&mut self) -> &mut ContextFlagsBuilder<'a> {\n            self.flags |= 0x0008;\n            self\n        }\n    }\n\n    pub struct ContextFlags {\n        flags: i32\n    }\n\n    impl ContextFlags {\n        #[inline]\n        pub fn has_debug(&self) -> bool { self.flags & 0x0001 != 0 }\n\n        #[inline]\n        pub fn has_forward_compatible(&self) -> bool { self.flags & 0x0002 != 0 }\n\n        #[inline]\n        pub fn has_robust_access(&self) -> bool { self.flags & 0x0004 != 0 }\n\n        #[inline]\n        pub fn has_reset_isolation(&self) -> bool { self.flags & 0x0008 != 0 }\n    }\n\n    impl<'a> GLAttr<'a> {\n\n    /// **Sets** any combination of OpenGL context configuration flags.\n    ///\n    /// Note that calling this will reset any existing context flags.\n    ///\n    /// # Example\n    /// ```no_run\n    /// let sdl_context = sdl2::init().unwrap();\n    /// let video_subsystem = sdl_context.video().unwrap();\n    /// let gl_attr = video_subsystem.gl_attr();\n    ///\n    /// // Sets the GL context into debug mode.\n    /// gl_attr.set_context_flags().debug().set();\n    /// ```\n    pub fn set_context_flags(&self) -> ContextFlagsBuilder {\n        ContextFlagsBuilder {\n            flags: 0,\n            _marker: PhantomData\n        }\n    }\n\n    /// **Gets** the applied OpenGL context configuration flags.\n    ///\n    /// # Example\n    /// ```no_run\n    /// let sdl_context = sdl2::init().unwrap();\n    /// let video_subsystem = sdl_context.video().unwrap();\n    /// let gl_attr = video_subsystem.gl_attr();\n    ///\n    /// // Is the GL context in debug mode?\n    /// if gl_attr.context_flags().has_debug() {\n    ///     println!(\"Debug mode\");\n    /// }\n    /// ```\n    pub fn context_flags(&self) -> ContextFlags {\n        let flags = gl_get_attribute!(SDL_GL_CONTEXT_FLAGS);\n\n        ContextFlags {\n            flags: flags\n        }\n    }\n\n    }\n}\n\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\npub struct DisplayMode {\n    pub format: PixelFormatEnum,\n    pub w: i32,\n    pub h: i32,\n    pub refresh_rate: i32\n}\n\nimpl DisplayMode {\n    pub fn new(format: PixelFormatEnum, w: i32, h: i32, refresh_rate: i32) -> DisplayMode {\n        DisplayMode {\n            format: format,\n            w: w,\n            h: h,\n            refresh_rate: refresh_rate\n        }\n    }\n\n    pub fn from_ll(raw: &ll::SDL_DisplayMode) -> DisplayMode {\n        DisplayMode::new(\n            PixelFormatEnum::from_u32(raw.format as u32).unwrap_or(PixelFormatEnum::Unknown),\n            raw.w as i32,\n            raw.h as i32,\n            raw.refresh_rate as i32\n        )\n    }\n\n    pub fn to_ll(&self) -> ll::SDL_DisplayMode {\n        ll::SDL_DisplayMode {\n            format: self.format as uint32_t,\n            w: self.w as c_int,\n            h: self.h as c_int,\n            refresh_rate: self.refresh_rate as c_int,\n            driverdata: ptr::null_mut()\n        }\n    }\n}\n\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\npub enum FullscreenType {\n    Off = 0,\n    True = 0x00000001,\n    Desktop = 0x00001001,\n}\n\nimpl FullscreenType {\n    pub fn from_window_flags(window_flags:u32) -> FullscreenType {\n        if window_flags & FullscreenType::Desktop as u32 == FullscreenType::Desktop as u32 {\n            FullscreenType::Desktop\n        } else if window_flags & FullscreenType::True as u32 == FullscreenType::True as u32  {\n            FullscreenType::True\n        } else {\n            FullscreenType::Off\n        }\n    }\n}\n\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\npub enum WindowPos {\n    Undefined,\n    Centered,\n    Positioned(i32)\n}\n\nfn to_ll_windowpos (pos: WindowPos) -> ll::SDL_WindowPos {\n    match pos {\n        WindowPos::Undefined => ll::SDL_WINDOWPOS_UNDEFINED,\n        WindowPos::Centered => ll::SDL_WINDOWPOS_CENTERED,\n        WindowPos::Positioned(x) => x as ll::SDL_WindowPos\n    }\n}\n\npub struct GLContext {\n    raw: ll::SDL_GLContext\n}\n\nimpl Drop for GLContext {\n    fn drop(&mut self) {\n        unsafe {\n            ll::SDL_GL_DeleteContext(self.raw)\n        }\n    }\n}\n\nimpl GLContext {\n    /// Returns true if the OpenGL context is the current one in the thread.\n    pub fn is_current(&self) -> bool {\n        let current_raw = unsafe { ll::SDL_GL_GetCurrentContext() };\n        self.raw == current_raw\n    }\n}\n\n/// Holds a `SDL_Window`\n///\n/// When the `WindowContext` is dropped, it destroys the `SDL_Window`\npub struct WindowContext {\n    subsystem: VideoSubsystem,\n    raw: *mut ll::SDL_Window,\n}\n\nimpl Drop for WindowContext {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe { ll::SDL_DestroyWindow(self.raw) };\n    }\n}\n\nimpl WindowContext {\n    #[inline]\n    /// Unsafe if the `*mut SDL_Window` is used after the `WindowContext` is dropped\n    pub unsafe fn from_ll(subsystem: VideoSubsystem, raw: *mut ll::SDL_Window) -> WindowContext {\n        WindowContext {\n            subsystem: subsystem.clone(),\n            raw: raw,\n        }\n    }\n}\n\n/// Represents the \"shell\" of a `Window`.\n///\n/// You can set get and set many of the SDL_Window properties (i.e., border, size, `PixelFormat`, etc)\n///\n/// However, you cannot directly access the pixels of the `Window`.\n/// It needs to be converted to a `Canvas` to access the rendering functions.\n///\n/// Note: If a `Window` goes out of scope but it cloned its context,\n/// then the `SDL_Window` will not be destroyed until there are no more references to the `WindowContext`.\n/// This may happen when a `TextureCreator<Window>` outlives the `Canvas<Window>`\npub struct Window {\n    context: Rc<WindowContext>,\n}\n\nimpl From<WindowContext> for Window {\n    fn from(context: WindowContext) -> Window {\n        Window { context: Rc::new(context) }\n    }\n}\n\nimpl_raw_accessors!(\n    (GLContext, ll::SDL_GLContext)\n);\n\nimpl VideoSubsystem {\n    /// Initializes a new `WindowBuilder`; a convenience method that calls `WindowBuilder::new()`.\n    pub fn window(&self, title: &str, width: u32, height: u32) -> WindowBuilder {\n        WindowBuilder::new(self, title, width, height)\n    }\n\n    pub fn current_video_driver(&self) -> &'static str {\n        use std::str;\n\n        unsafe {\n            let buf = ll::SDL_GetCurrentVideoDriver();\n            assert!(!buf.is_null());\n\n            str::from_utf8(CStr::from_ptr(buf as *const _).to_bytes()).unwrap()\n        }\n    }\n\n    pub fn num_video_displays(&self) -> Result<i32, String> {\n        let result = unsafe { ll::SDL_GetNumVideoDisplays() };\n        if result < 0 {\n            Err(get_error())\n        } else {\n            Ok(result as i32)\n        }\n    }\n\n    /// Get the name of the display at the index `display_name`.\n    ///\n    /// Will return an error if the index is out of bounds or if SDL experienced a failure; inspect\n    /// the returned string for further info.\n    pub fn display_name(&self, display_index: i32) -> Result<String, String> {\n        unsafe {\n            let display = ll::SDL_GetDisplayName(display_index as c_int);\n            if display.is_null() {\n                Err(get_error())\n            } else {\n                Ok(CStr::from_ptr(display as *const _).to_str().unwrap().to_owned())\n            }\n        }\n    }\n\n    pub fn display_bounds(&self, display_index: i32) -> Result<Rect, String> {\n        let mut out = unsafe { mem::uninitialized() };\n        let result = unsafe { ll::SDL_GetDisplayBounds(display_index as c_int, &mut out) == 0 };\n\n        if result {\n            Ok(Rect::from_ll(out))\n        } else {\n            Err(get_error())\n        }\n    }\n\n    pub fn num_display_modes(&self, display_index: i32) -> Result<i32, String> {\n        let result = unsafe { ll::SDL_GetNumDisplayModes(display_index as c_int) };\n        if result < 0 {\n            Err(get_error())\n        } else {\n            Ok(result as i32)\n        }\n    }\n\n    pub fn display_mode(&self, display_index: i32, mode_index: i32) -> Result<DisplayMode, String> {\n        let mut dm = unsafe { mem::uninitialized() };\n        let result = unsafe { ll::SDL_GetDisplayMode(display_index as c_int, mode_index as c_int, &mut dm) == 0};\n\n        if result {\n            Ok(DisplayMode::from_ll(&dm))\n        } else {\n            Err(get_error())\n        }\n    }\n\n    pub fn desktop_display_mode(&self, display_index: i32) -> Result<DisplayMode, String> {\n        let mut dm = unsafe { mem::uninitialized() };\n        let result = unsafe { ll::SDL_GetDesktopDisplayMode(display_index as c_int, &mut dm) == 0};\n\n        if result {\n            Ok(DisplayMode::from_ll(&dm))\n        } else {\n            Err(get_error())\n        }\n    }\n\n    pub fn current_display_mode(&self, display_index: i32) -> Result<DisplayMode, String> {\n        let mut dm = unsafe { mem::uninitialized() };\n        let result = unsafe { ll::SDL_GetCurrentDisplayMode(display_index as c_int, &mut dm) == 0};\n\n        if result {\n            Ok(DisplayMode::from_ll(&dm))\n        } else {\n            Err(get_error())\n        }\n    }\n\n    pub fn closest_display_mode(&self, display_index: i32, mode: &DisplayMode) -> Result<DisplayMode, String> {\n        let input = mode.to_ll();\n        let mut dm = unsafe { mem::uninitialized() };\n\n        let result = unsafe { ll::SDL_GetClosestDisplayMode(display_index as c_int, &input, &mut dm) };\n\n        if result.is_null() {\n            Err(get_error())\n        } else {\n            Ok(DisplayMode::from_ll(&dm))\n        }\n    }\n\n    /// Return a triplet `(ddpi, hdpi, vdpi)` containing the diagonal, horizontal and vertical\n    /// dots/pixels-per-inch of a display\n    pub fn display_dpi(&self, display_index: i32) -> Result<(f32, f32, f32), String> {\n        let mut ddpi = 0.0;\n        let mut hdpi = 0.0;\n        let mut vdpi = 0.0;\n        let result = unsafe { ll::SDL_GetDisplayDPI(display_index as c_int, &mut ddpi, &mut hdpi, &mut vdpi) };\n        if result < 0 {\n            Err(get_error())\n        } else {\n            Ok((ddpi, hdpi, vdpi))\n        }\n    }\n\n    pub fn is_screen_saver_enabled(&self) -> bool {\n        unsafe { ll::SDL_IsScreenSaverEnabled() == 1 }\n    }\n\n    pub fn enable_screen_saver(&self) {\n        unsafe { ll::SDL_EnableScreenSaver() }\n    }\n\n    pub fn disable_screen_saver(&self) {\n        unsafe { ll::SDL_DisableScreenSaver() }\n    }\n\n    /// Loads the default OpenGL library.\n    ///\n    /// This should be done after initializing the video driver, but before creating any OpenGL windows.\n    /// If no OpenGL library is loaded, the default library will be loaded upon creation of the first OpenGL window.\n    ///\n    /// If a different library is already loaded, this function will return an error.\n    pub fn gl_load_library_default(&self) -> Result<(), String> {\n        unsafe {\n            if ll::SDL_GL_LoadLibrary(ptr::null()) == 0 {\n                Ok(())\n            } else {\n                Err(get_error())\n            }\n        }\n    }\n\n    /// Loads the OpenGL library using a platform-dependent OpenGL library name (usually a file path).\n    ///\n    /// This should be done after initializing the video driver, but before creating any OpenGL windows.\n    /// If no OpenGL library is loaded, the default library will be loaded upon creation of the first OpenGL window.\n    ///\n    /// If a different library is already loaded, this function will return an error.\n    pub fn gl_load_library<P: AsRef<::std::path::Path>>(&self, path: P) -> Result<(), String> {\n        unsafe {\n            // TODO: use OsStr::to_cstring() once it's stable\n            let path = CString::new(path.as_ref().to_str().unwrap()).unwrap();\n            if ll::SDL_GL_LoadLibrary(path.as_ptr() as *const c_char) == 0 {\n                Ok(())\n            } else {\n                Err(get_error())\n            }\n        }\n    }\n\n    /// Unloads the current OpenGL library.\n    ///\n    /// To completely unload the library, this should be called for every successful load of the\n    /// OpenGL library.\n    pub fn gl_unload_library(&self) {\n        unsafe { ll::SDL_GL_UnloadLibrary(); }\n    }\n\n    /// Gets the pointer to the named OpenGL function.\n    ///\n    /// This is useful for OpenGL wrappers such as [`gl-rs`](https://github.com/bjz/gl-rs).\n    pub fn gl_get_proc_address(&self, procname: &str) -> *const () {\n        match CString::new(procname) {\n            Ok(procname) => unsafe { ll::SDL_GL_GetProcAddress(procname.as_ptr() as *const c_char) as *const () },\n            // string contains a nul byte - it won't match anything.\n            Err(_) => ptr::null()\n        }\n    }\n\n    pub fn gl_extension_supported(&self, extension: &str) -> bool {\n        match CString::new(extension) {\n            Ok(extension) => unsafe { ll::SDL_GL_ExtensionSupported(extension.as_ptr() as *const c_char) != 0 },\n            // string contains a nul byte - it won't match anything.\n            Err(_) => false\n        }\n    }\n\n    pub fn gl_get_current_window_id(&self) -> Result<u32, String> {\n        let raw = unsafe { ll::SDL_GL_GetCurrentWindow() };\n        if raw.is_null() {\n            Err(get_error())\n        } else {\n            let id = unsafe { ll::SDL_GetWindowID(raw) };\n            Ok(id)\n        }\n    }\n\n    /// Releases the thread's current OpenGL context, i.e. sets the current OpenGL context to nothing.\n    pub fn gl_release_current_context(&self) -> Result<(), String> {\n        let result = unsafe { ll::SDL_GL_MakeCurrent(ptr::null_mut(), ptr::null()) };\n\n        if result == 0 {\n            Ok(())\n        } else {\n            Err(get_error())\n        }\n    }\n\n    pub fn gl_set_swap_interval(&self, interval: i32) -> bool {\n        unsafe { ll::SDL_GL_SetSwapInterval(interval as c_int) == 0 }\n    }\n\n    pub fn gl_get_swap_interval(&self) -> i32 {\n        unsafe { ll::SDL_GL_GetSwapInterval() as i32 }\n    }\n}\n\n#[derive(Debug)]\npub enum WindowBuildError {\n    HeightOverflows(u32),\n    WidthOverflows(u32),\n    InvalidTitle(NulError),\n    SdlError(String),\n}\n\nimpl fmt::Display for WindowBuildError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::WindowBuildError::*;\n\n        match *self {\n            HeightOverflows(h) => write!(f, \"Window height ({}) is too high.\", h),\n            WidthOverflows(w) => write!(f, \"Window width ({}) is too high.\", w),\n            InvalidTitle(ref e) => write!(f, \"Invalid window title: {}\", e),\n            SdlError(ref e) => write!(f, \"SDL error: {}\", e),\n        }\n    }\n}\n\nimpl Error for WindowBuildError {\n    fn description(&self) -> &str {\n        use self::WindowBuildError::*;\n\n        match *self {\n            HeightOverflows(_) => \"window height overflow\",\n            WidthOverflows(_) => \"window width overflow\",\n            InvalidTitle(_) => \"invalid window title\",\n            SdlError(ref e) => e,\n        }\n    }\n}\n\n/// The type that allows you to build windows.\n#[derive(Debug)]\npub struct WindowBuilder {\n    title: String,\n    width: u32,\n    height: u32,\n    x: WindowPos,\n    y: WindowPos,\n    window_flags: u32,\n    /// The window builder cannot be built on a non-main thread, so prevent cross-threaded moves and references.\n    /// `!Send` and `!Sync`,\n    subsystem: VideoSubsystem\n}\n\nimpl WindowBuilder {\n    /// Initializes a new `WindowBuilder`.\n    pub fn new(v: &VideoSubsystem, title: &str, width: u32, height: u32) -> WindowBuilder {\n        WindowBuilder {\n            title: title.to_owned(),\n            width: width,\n            height: height,\n            x: WindowPos::Undefined,\n            y: WindowPos::Undefined,\n            window_flags: 0,\n            subsystem: v.clone()\n        }\n    }\n\n    /// Builds the window.\n    pub fn build(&self) -> Result<Window, WindowBuildError> {\n        use self::WindowBuildError::*;\n        let title = match CString::new(self.title.clone()) {\n            Ok(t) => t,\n            Err(err) => return Err(InvalidTitle(err)),\n        };\n        if self.width >= (1 << 31) {\n            return Err(WidthOverflows(self.width));\n        }\n        if self.height >= (1 << 31) {\n            return Err(HeightOverflows(self.width));\n        }\n\n        let raw_width = self.width as c_int;\n        let raw_height = self.height as c_int;\n        unsafe {\n            let raw = ll::SDL_CreateWindow(\n                title.as_ptr() as *const c_char,\n                to_ll_windowpos(self.x),\n                to_ll_windowpos(self.y),\n                raw_width,\n                raw_height,\n                self.window_flags\n            );\n\n            if raw.is_null() {\n                Err(SdlError(get_error()))\n            } else {\n                Ok(Window::from_ll(self.subsystem.clone(), raw))\n            }\n        }\n    }\n\n    /// Gets the underlying window flags.\n    pub fn window_flags(&self) -> u32 { self.window_flags }\n\n    /// Sets the underlying window flags.\n    /// This will effectively undo any previous build operations, excluding window size and position.\n    pub fn set_window_flags(&mut self, flags: u32) -> &mut WindowBuilder {\n        self.window_flags = flags;\n        self\n    }\n\n    /// Sets the window position.\n    pub fn position(&mut self, x: i32, y: i32) -> &mut WindowBuilder {\n        self.x = WindowPos::Positioned(x);\n        self.y = WindowPos::Positioned(y);\n        self\n    }\n\n    /// Centers the window.\n    pub fn position_centered(&mut self) -> &mut WindowBuilder {\n        self.x = WindowPos::Centered;\n        self.y = WindowPos::Centered;\n        self\n    }\n\n    /// Sets the window to fullscreen.\n    pub fn fullscreen(&mut self) -> &mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_FULLSCREEN as u32;\n        self\n    }\n\n    /// Sets the window to fullscreen at the current desktop resolution.\n    pub fn fullscreen_desktop(&mut self) -> &mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_FULLSCREEN_DESKTOP as u32;\n        self\n    }\n\n    /// Sets the window to be usable with an OpenGL context\n    pub fn opengl(&mut self) -> & mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_OPENGL as u32;\n        self\n    }\n\n    /// Hides the window.\n    pub fn hidden(&mut self) -> &mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_HIDDEN as u32;\n        self\n    }\n\n    /// Removes the window decoration.\n    pub fn borderless(&mut self) -> &mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_BORDERLESS as u32;\n        self\n    }\n\n    /// Sets the window to be resizable.\n    pub fn resizable(&mut self) -> &mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_RESIZABLE as u32;\n        self\n    }\n\n    /// Minimizes the window.\n    pub fn minimized(&mut self) -> &mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_MINIMIZED as u32;\n        self\n    }\n\n    /// Maximizes the window.\n    pub fn maximized(&mut self) -> &mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_MAXIMIZED as u32;\n        self\n    }\n\n    /// Sets the window to have grabbed input focus.\n    pub fn input_grabbed(&mut self) -> &mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_INPUT_GRABBED as u32;\n        self\n    }\n\n    /// Creates the window in high-DPI mode if supported (>= SDL 2.0.1)\n    pub fn allow_highdpi(&mut self) -> &mut WindowBuilder {\n        self.window_flags |= ll::SDL_WindowFlags::SDL_WINDOW_ALLOW_HIGHDPI as u32;\n        self\n    }\n}\n\nimpl From<Window> for CanvasBuilder {\n    fn from(window: Window) -> CanvasBuilder {\n        CanvasBuilder::new(window)\n    }\n}\n\nimpl Window {\n    #[inline]\n    pub fn raw(&self) -> *mut ll::SDL_Window { self.context.raw }\n\n    #[inline]\n    pub unsafe fn from_ll(subsystem: VideoSubsystem, raw: *mut ll::SDL_Window) -> Window {\n        let context = WindowContext::from_ll(subsystem, raw);\n        context.into()\n    }\n\n    #[inline]\n    /// Create a new `Window` without taking ownership of the `WindowContext`\n    pub unsafe fn from_ref(context: Rc<WindowContext>) -> Window {\n        Window { context: context }\n    }\n\n    #[inline]\n    pub fn subsystem(&self) -> &VideoSubsystem { &self.context.subsystem }\n\n    /// Initializes a new `CanvasBuilder`; a convenience method that calls `CanvasBuilder::new()`.\n    pub fn into_canvas(self) -> CanvasBuilder {\n        self.into()\n    }\n\n    pub fn context(&self) -> Rc<WindowContext> {\n        self.context.clone()\n    }\n\n    pub fn id(&self) -> u32 {\n        unsafe { ll::SDL_GetWindowID(self.context.raw) }\n    }\n\n    pub fn gl_create_context(&self) -> Result<GLContext, String> {\n        let result = unsafe { ll::SDL_GL_CreateContext(self.context.raw) };\n        if result.is_null() {\n            Err(get_error())\n        } else {\n            Ok(GLContext{ raw: result })\n        }\n    }\n\n    /// Set the window's OpenGL context to the current context on the thread.\n    pub fn gl_set_context_to_current(&self) -> Result<(), String> {\n        unsafe {\n            let context_raw = ll::SDL_GL_GetCurrentContext();\n\n            if context_raw.is_null() {\n                Err(get_error())\n            } else {\n                if ll::SDL_GL_MakeCurrent(self.context.raw, context_raw) == 0 {\n                    Ok(())\n                } else {\n                    Err(get_error())\n                }\n            }\n        }\n    }\n\n    pub fn gl_make_current(&self, context: &GLContext) -> Result<(), String> {\n        unsafe {\n            if ll::SDL_GL_MakeCurrent(self.context.raw, context.raw) == 0 {\n                Ok(())\n            } else {\n                Err(get_error())\n            }\n        }\n    }\n\n    pub fn gl_swap_window(&self) {\n        unsafe { ll::SDL_GL_SwapWindow(self.context.raw) }\n    }\n\n    pub fn display_index(&self) -> Result<i32, String> {\n        let result = unsafe { ll::SDL_GetWindowDisplayIndex(self.context.raw) };\n        if result < 0 {\n            return Err(get_error())\n        } else {\n            Ok(result as i32)\n        }\n    }\n\n    pub fn set_display_mode<D>(&mut self, display_mode: D) -> Result<(), String>\n    where D: Into<Option<DisplayMode>>\n    {\n        unsafe {\n            let result = ll::SDL_SetWindowDisplayMode(\n                self.context.raw,\n                match display_mode.into() {\n                    Some(ref mode) => &mode.to_ll(),\n                    None => ptr::null()\n                }\n            );\n            if result < 0 {\n                Err(get_error())\n            } else {\n                Ok(())\n            }\n        }\n    }\n\n    pub fn display_mode(&self) -> Result<DisplayMode, String> {\n        let mut dm = unsafe { mem::uninitialized() };\n\n        let result = unsafe {\n            ll::SDL_GetWindowDisplayMode(\n                self.context.raw,\n                &mut dm\n            ) == 0\n        };\n\n        if result {\n            Ok(DisplayMode::from_ll(&dm))\n        } else {\n            Err(get_error())\n        }\n    }\n\n    pub fn window_pixel_format(&self) -> PixelFormatEnum {\n        unsafe{ FromPrimitive::from_u64(ll::SDL_GetWindowPixelFormat(self.context.raw) as u64).unwrap() }\n    }\n\n    pub fn window_flags(&self) -> u32 {\n        unsafe {\n            ll::SDL_GetWindowFlags(self.context.raw)\n        }\n    }\n\n    pub fn set_title(&mut self, title: &str) -> Result<(), NulError> {\n        let title = try!(CString::new(title));\n        Ok(unsafe {\n            ll::SDL_SetWindowTitle(self.context.raw, title.as_ptr() as *const c_char);\n        })\n    }\n\n    pub fn title(&self) -> &str {\n        unsafe {\n            let buf = ll::SDL_GetWindowTitle(self.context.raw);\n\n            // The window title must be encoded in UTF-8.\n            CStr::from_ptr(buf as *const _).to_str().unwrap()\n        }\n    }\n\n    pub fn set_icon<S: AsRef<SurfaceRef>>(&mut self, icon: S) {\n        unsafe {\n            ll::SDL_SetWindowIcon(self.context.raw, icon.as_ref().raw())\n        }\n    }\n\n    //pub fn SDL_SetWindowData(window: *SDL_Window, name: *c_char, userdata: *c_void) -> *c_void; //TODO: Figure out what this does\n    //pub fn SDL_GetWindowData(window: *SDL_Window, name: *c_char) -> *c_void;\n\n    pub fn set_position(&mut self, x: WindowPos, y: WindowPos) {\n        unsafe {\n            ll::SDL_SetWindowPosition(\n                self.context.raw, to_ll_windowpos(x), to_ll_windowpos(y)\n            )\n        }\n    }\n\n    pub fn position(&self) -> (i32, i32) {\n        let mut x: c_int = 0;\n        let mut y: c_int = 0;\n        unsafe { ll::SDL_GetWindowPosition(self.context.raw, &mut x, &mut y) };\n        (x as i32, y as i32)\n    }\n\n    pub fn set_size(&mut self, width: u32, height: u32)\n            -> Result<(), IntegerOrSdlError> {\n        let w = try!(validate_int(width, \"width\"));\n        let h = try!(validate_int(height, \"height\"));\n        Ok(unsafe {\n            ll::SDL_SetWindowSize(self.context.raw, w, h)\n        })\n    }\n\n    pub fn size(&self) -> (u32, u32) {\n        let mut w: c_int = 0;\n        let mut h: c_int = 0;\n        unsafe { ll::SDL_GetWindowSize(self.context.raw, &mut w, &mut h) };\n        (w as u32, h as u32)\n    }\n\n    pub fn drawable_size(&self) -> (u32, u32) {\n        let mut w: c_int = 0;\n        let mut h: c_int = 0;\n        unsafe { ll::SDL_GL_GetDrawableSize(self.context.raw, &mut w, &mut h) };\n        (w as u32, h as u32)\n    }\n\n    pub fn set_minimum_size(&mut self, width: u32, height: u32)\n            -> Result<(), IntegerOrSdlError> {\n        let w = try!(validate_int(width, \"width\"));\n        let h = try!(validate_int(height, \"height\"));\n        Ok(unsafe {\n            ll::SDL_SetWindowMinimumSize(self.context.raw, w, h)\n        })\n    }\n\n    pub fn minimum_size(&self) -> (u32, u32) {\n        let mut w: c_int = 0;\n        let mut h: c_int = 0;\n        unsafe { ll::SDL_GetWindowMinimumSize(self.context.raw, &mut w, &mut h) };\n        (w as u32, h as u32)\n    }\n\n    pub fn set_maximum_size(&mut self, width: u32, height: u32)\n            -> Result<(), IntegerOrSdlError> {\n        let w = try!(validate_int(width, \"width\"));\n        let h = try!(validate_int(height, \"height\"));\n        Ok(unsafe {\n            ll::SDL_SetWindowMaximumSize(self.context.raw, w, h)\n        })\n    }\n\n    pub fn maximum_size(&self) -> (u32, u32) {\n        let mut w: c_int = 0;\n        let mut h: c_int = 0;\n        unsafe {\n            ll::SDL_GetWindowMaximumSize(self.context.raw, &mut w, &mut h)\n        };\n        (w as u32, h as u32)\n    }\n\n    pub fn set_bordered(&mut self, bordered: bool) {\n        unsafe {\n            ll::SDL_SetWindowBordered(\n                self.context.raw,\n                if bordered { 1 } else { 0 }\n            )\n        }\n    }\n\n    pub fn show(&mut self) {\n        unsafe { ll::SDL_ShowWindow(self.context.raw) }\n    }\n\n    pub fn hide(&mut self) {\n        unsafe { ll::SDL_HideWindow(self.context.raw) }\n    }\n\n    pub fn raise(&mut self) {\n        unsafe { ll::SDL_RaiseWindow(self.context.raw) }\n    }\n\n    pub fn maximize(&mut self) {\n        unsafe { ll::SDL_MaximizeWindow(self.context.raw) }\n    }\n\n    pub fn minimize(&mut self) {\n        unsafe { ll::SDL_MinimizeWindow(self.context.raw) }\n    }\n\n    pub fn restore(&mut self) {\n        unsafe { ll::SDL_RestoreWindow(self.context.raw) }\n    }\n\n    pub fn fullscreen_state(&self) -> FullscreenType {\n        FullscreenType::from_window_flags(self.window_flags())\n    }\n\n    pub fn set_fullscreen(&mut self, fullscreen_type: FullscreenType)\n            -> Result<(), String> {\n        unsafe {\n            let result = ll::SDL_SetWindowFullscreen(\n                self.context.raw, fullscreen_type as uint32_t\n            );\n            if result == 0 {\n                Ok(())\n            } else {\n                Err(get_error())\n            }\n        }\n    }\n\n    /// Returns a WindowSurfaceRef, which can be used like a regular Surface. This is an\n    /// alternative way to the Renderer (Canvas) way to modify pixels directly in the Window.\n    /// \n    /// For this to happen, simply create a `WindowSurfaceRef` via this method, use the underlying\n    /// Surface however you like, and when the changes of the Surface must be applied to the\n    /// screen, call `update_window` if you intend to keep using the WindowSurfaceRef afterwards,\n    /// or `finish` if you don't intend to use it afterwards.\n    ///\n    /// The Renderer way is of course much more flexible and recommended; even though you only want\n    /// to support Software Rendering (which is what using Surface is), you can still create a\n    /// Renderer which renders in a Software-based manner, so try to rely on a Renderer as much as\n    /// possible !\n    pub fn surface<'a>(&'a self, _e: &'a EventPump) -> Result<WindowSurfaceRef<'a>, String> {\n        let raw = unsafe { ll::SDL_GetWindowSurface(self.context.raw) };\n\n        if raw.is_null() {\n            Err(get_error())\n        } else {\n            let surface_ref = unsafe { SurfaceRef::from_ll_mut(raw) };\n            Ok(WindowSurfaceRef(surface_ref, self))\n        }\n    }\n\n    pub fn set_grab(&mut self, grabbed: bool) {\n        unsafe { ll::SDL_SetWindowGrab(self.context.raw, if grabbed { 1 } else { 0 }) }\n    }\n\n    pub fn grab(&self) -> bool {\n        unsafe { ll::SDL_GetWindowGrab(self.context.raw) == 1 }\n    }\n\n    pub fn set_brightness(&mut self, brightness: f64) -> Result<(), String> {\n        unsafe {\n            if ll::SDL_SetWindowBrightness(self.context.raw, brightness as c_float) == 0 {\n                Ok(())\n            } else {\n                Err(get_error())\n            }\n        }\n    }\n\n    pub fn brightness(&self) -> f64 {\n        unsafe { ll::SDL_GetWindowBrightness(self.context.raw) as f64 }\n    }\n\n    pub fn set_gamma_ramp<'a, 'b, 'c, R, G, B>(&mut self, red: R, green: G, blue: B) -> Result<(), String> \n    where R: Into<Option<&'a [u16; 256]>>,\n          G: Into<Option<&'b [u16; 256]>>,\n          B: Into<Option<&'c [u16; 256]>>,\n    {\n        let unwrapped_red = match red.into() {\n            Some(values) => values.as_ptr(),\n            None => ptr::null()\n        };\n        let unwrapped_green = match green.into() {\n            Some(values) => values.as_ptr(),\n            None => ptr::null()\n        };\n        let unwrapped_blue = match blue.into() {\n            Some(values) => values.as_ptr(),\n            None => ptr::null()\n        };\n        let result = unsafe {\n            ll::SDL_SetWindowGammaRamp(\n                self.context.raw, unwrapped_red, unwrapped_green, unwrapped_blue\n            )\n        };\n        if result != 0 {\n            Err(get_error())\n        } else {\n            Ok(())\n        }\n    }\n\n    pub fn gamma_ramp(&self) -> Result<(Vec<u16>, Vec<u16>, Vec<u16>), String> {\n        let mut red: Vec<u16> = Vec::with_capacity(256);\n        let mut green: Vec<u16> = Vec::with_capacity(256);\n        let mut blue: Vec<u16> = Vec::with_capacity(256);\n        let result = unsafe {\n            ll::SDL_GetWindowGammaRamp(\n                self.context.raw, red.as_mut_ptr(), green.as_mut_ptr(),\n                blue.as_mut_ptr()\n            )\n        };\n        if result == 0 {\n            Ok((red, green, blue))\n        } else {\n            Err(get_error())\n        }\n    }\n}\n\n#[derive(Copy, Clone)]\npub struct DriverIterator {\n    length: i32,\n    index: i32\n}\n\nimpl Iterator for DriverIterator {\n    type Item = &'static str;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'static str> {\n        if self.index >= self.length {\n            None\n        } else {\n            use std::str;\n\n            unsafe {\n                let buf = ll::SDL_GetVideoDriver(self.index);\n                assert!(!buf.is_null());\n                self.index += 1;\n\n                Some(str::from_utf8(CStr::from_ptr(buf as *const _).to_bytes()).unwrap())\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let l = self.length as usize;\n        (l, Some(l))\n    }\n}\n\nimpl ExactSizeIterator for DriverIterator { }\n\n/// Gets an iterator of all video drivers compiled into the SDL2 library.\n#[inline]\npub fn drivers() -> DriverIterator {\n    // This function is thread-safe and doesn't require the video subsystem to be initialized.\n    // The list of drivers are read-only and statically compiled into SDL2, varying by platform.\n\n    // SDL_GetNumVideoDrivers can never return a negative value.\n    DriverIterator {\n        length: unsafe { ll::SDL_GetNumVideoDrivers() },\n        index: 0\n    }\n}\n",null,null,null,"extern crate sdl2;\nuse std::path::Path;\n\nuse sdl2::rect::Rect;\nuse sdl2::rect::Point;\n\nuse std::os::raw::{c_void, c_int};\nuse std::ptr::null_mut;\n\nuse std::cell::RefCell;\n\n#[allow(non_camel_case_types)]\ntype em_callback_func = unsafe extern fn();\nextern {\n    fn emscripten_set_main_loop(func: em_callback_func,\n                                fps: c_int,\n                                simulate_infinite_loop: c_int);\n}\n\nthread_local!(static MAIN_LOOP_CALLBACK: RefCell<*mut c_void> = RefCell::new(null_mut()));\n\npub fn set_main_loop_callback<F>(callback: F) where F: FnMut() {\n    MAIN_LOOP_CALLBACK.with(|log| {\n        *log.borrow_mut() = &callback as *const _ as *mut c_void;\n    });\n\n    unsafe { emscripten_set_main_loop(wrapper::<F>, 0, 1); }\n}\n\nunsafe extern \"C\" fn wrapper<F>() where F : FnMut() {\n    MAIN_LOOP_CALLBACK.with(|z| {\n        let closure = *z.borrow_mut() as *mut F;\n        (*closure)();\n    });\n}\n\nfn main() {\n    let sdl_context = sdl2::init().unwrap();\n    let video_subsystem = sdl_context.video().unwrap();\n\n    let window = video_subsystem.window(\"SDL2\", 640, 480)\n        .position_centered().build().unwrap();\n\n    let mut canvas = window.into_canvas()\n        .accelerated().build().unwrap();\n    let texture_creator = canvas.texture_creator();\n\n    canvas.set_draw_color(sdl2::pixels::Color::RGBA(0,0,0,255));\n\n    let mut timer = sdl_context.timer().unwrap();\n\n    let temp_surface = sdl2::surface::Surface::load_bmp(Path::new(\"animate.bmp\")).unwrap();\n    let texture = texture_creator.create_texture_from_surface(&temp_surface).unwrap();\n    \n    let center = Point::new(320,240);\n    let mut source_rect = Rect::new(0, 0, 128, 82);\n    let mut dest_rect = Rect::new(0,0, 128, 82);\n    dest_rect.center_on(center);\n\n    set_main_loop_callback(|| {\n        let ticks = timer.ticks();\n\n        source_rect.set_x((128 * ((ticks / 100) % 6) ) as i32);\n        canvas.clear();\n        canvas.copy_ex(&texture, Some(source_rect), Some(dest_rect), 10.0, None, true, false).unwrap();\n        canvas.present();\n    });\n}",null,"use std::error::Error;\nuse std::fmt;\n\n/// A given integer was so big that its representation as a C integer would be\n/// negative.\n#[derive(Debug)]\npub enum IntegerOrSdlError {\n    IntegerOverflows(&'static str, u32),\n    SdlError(String)\n}\n/// Validates and converts the given u32 to a positive C integer.\npub fn validate_int(value: u32, name: &'static str)\n        -> Result<::libc::c_int, IntegerOrSdlError> {\n    use self::IntegerOrSdlError::*;\n    // Many SDL functions will accept `int` values, even if it doesn't make sense\n    // for the values to be negative.\n    // In the cases that SDL doesn't check negativity, passing negative values\n    // could be unsafe.\n    // For example, `SDL_JoystickGetButton` uses the index argument to access an\n    // array without checking if it's negative, which could potentially lead to\n    // segmentation faults.\n    if value >= 1 << 31 {\n        Err(IntegerOverflows(name, value))\n    } else {\n        Ok(value as ::libc::c_int)\n    }\n}\n\nimpl fmt::Display for IntegerOrSdlError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::IntegerOrSdlError::*;\n\n        match *self {\n            IntegerOverflows(name, value) => write!(f, \"Integer '{}' overflows ({})\", name, value),\n            SdlError(ref e) => write!(f, \"SDL error: {}\", e),\n        }\n    }\n}\n\nimpl Error for IntegerOrSdlError {\n    fn description(&self) -> &str {\n        use self::IntegerOrSdlError::*;\n\n        match *self {\n            IntegerOverflows(_, _) => \"integer overflow\",\n            SdlError(ref e) => e,\n        }\n    }\n}\n","use libc::{uint32_t, c_void};\nuse std::marker::PhantomData;\nuse std::mem;\nuse sys::timer as ll;\n\nuse TimerSubsystem;\n\nimpl TimerSubsystem {\n    /// Constructs a new timer using the boxed closure `callback`.\n    ///\n    /// The timer is started immediately, it will be cancelled either:\n    ///\n    /// * when the timer is dropped\n    /// * or when the callback returns a non-positive continuation interval\n    pub fn add_timer<'b, 'c>(&'b self, delay: u32, callback: TimerCallback<'c>) -> Timer<'b, 'c> {\n        unsafe {\n            let callback = Box::new(callback);\n            let timer_id = ll::SDL_AddTimer(delay,\n                                            Some(c_timer_callback),\n                                            mem::transmute_copy(&callback));\n\n            Timer {\n                callback: Some(callback),\n                raw: timer_id,\n                _marker: PhantomData\n            }\n        }\n    }\n\n    /// Gets the number of milliseconds elapsed since the timer subsystem was initialized.\n    ///\n    /// It's recommended that you use another library for timekeeping, such as `time`.\n    pub fn ticks(&mut self) -> u32 {\n        // Google says this is probably not thread-safe (TODO: prove/disprove this).\n        unsafe { ll::SDL_GetTicks() }\n    }\n\n    /// Sleeps the current thread for the specified amount of milliseconds.\n    ///\n    /// It's recommended that you use `std::thread::sleep()` instead.\n    pub fn delay(&mut self, ms: u32) {\n        // Google says this is probably not thread-safe (TODO: prove/disprove this).\n        unsafe { ll::SDL_Delay(ms) }\n    }\n\n    pub fn performance_counter(&self) -> u64 {\n        unsafe { ll::SDL_GetPerformanceCounter() }\n    }\n\n    pub fn performance_frequency(&self) -> u64 {\n        unsafe { ll::SDL_GetPerformanceFrequency() }\n    }\n}\n\npub type TimerCallback<'a> = Box<FnMut() -> u32+'a+Sync>;\n\npub struct Timer<'b, 'a> {\n    callback: Option<Box<TimerCallback<'a>>>,\n    raw: ll::SDL_TimerID,\n    _marker: PhantomData<&'b ()>\n}\n\nimpl<'b, 'a> Timer<'b, 'a> {\n    /// Returns the closure as a trait-object and cancels the timer\n    /// by consuming it...\n    pub fn into_inner(mut self) -> TimerCallback<'a> {\n        *self.callback.take().unwrap()\n    }\n}\n\nimpl<'b, 'a> Drop for Timer<'b, 'a> {\n    #[inline]\n    fn drop(&mut self) {\n        // SDL_RemoveTimer returns SDL_FALSE if the timer wasn't found (impossible),\n        // or the timer has been cancelled via the callback (possible).\n        // The timer being cancelled isn't an issue, so we ignore the result.\n        unsafe { ll::SDL_RemoveTimer(self.raw) };\n    }\n}\n\nextern \"C\" fn c_timer_callback(_interval: u32, param: *mut c_void) -> uint32_t {\n    unsafe {\n        let f: *mut Box<Fn() -> u32> = mem::transmute(param);\n        (*f)() as uint32_t\n    }\n}\n\n\n#[cfg(test)]\nfn test_timer_runs_multiple_times() {\n    use std::sync::{Arc, Mutex};\n    use std::time::Duration;\n    \n    let sdl_context = ::sdl::init().unwrap();\n    let timer_subsystem = sdl_context.timer().unwrap();\n\n    let local_num = Arc::new(Mutex::new(0));\n    let timer_num = local_num.clone();\n\n    let _timer = timer_subsystem.add_timer(20, Box::new(|| {\n        // increment up to 10 times (0 -> 9)\n        // tick again in 100ms after each increment\n        //\n        let mut num = timer_num.lock().unwrap();\n        if *num < 9 {\n            *num += 1;\n            20\n        } else { 0 }\n    }));\n\n    ::std::thread::sleep(Duration::from_millis(250));              // tick the timer at least 10 times w/ 200ms of \"buffer\"\n    let num = local_num.lock().unwrap(); // read the number back\n    assert_eq!(*num, 9);                 // it should have incremented at least 10 times...\n}\n\n#[cfg(test)]\nfn test_timer_runs_at_least_once() {\n    use std::sync::{Arc, Mutex};\n    use std::time::Duration;\n    \n    let sdl_context = ::sdl::init().unwrap();\n    let timer_subsystem = sdl_context.timer().unwrap();\n\n    let local_flag = Arc::new(Mutex::new(false));\n    let timer_flag = local_flag.clone();\n\n    let _timer = timer_subsystem.add_timer(20, Box::new(|| {\n        let mut flag = timer_flag.lock().unwrap();\n        *flag = true; 0\n    }));\n\n    ::std::thread::sleep(Duration::from_millis(50));\n    let flag = local_flag.lock().unwrap();\n    assert_eq!(*flag, true);\n}\n\n#[cfg(test)]\nfn test_timer_can_be_recreated() {\n    use std::time::Duration;\n    use std::sync::{Arc, Mutex};\n    \n    let sdl_context = ::sdl::init().unwrap();\n    let timer_subsystem = sdl_context.timer().unwrap();\n\n    let local_num = Arc::new(Mutex::new(0));\n    let timer_num = local_num.clone();\n\n    // run the timer once and reclaim its closure\n    let timer_1 = timer_subsystem.add_timer(20, Box::new(move|| {\n        let mut num = timer_num.lock().unwrap();\n        *num += 1; // increment the number\n        0          // do not run timer again\n    }));\n\n    // reclaim closure after timer runs\n    ::std::thread::sleep(Duration::from_millis(50));\n    let closure = timer_1.into_inner();\n\n    // create a second timer and increment again\n    let _timer_2 = timer_subsystem.add_timer(20, closure);\n    ::std::thread::sleep(Duration::from_millis(50));\n\n    // check that timer was incremented twice\n    let num = local_num.lock().unwrap();\n    assert_eq!(*num, 2);\n}\n\n#[test]\nfn test_timer() {\n    test_timer_runs_multiple_times();\n    test_timer_runs_at_least_once();\n    test_timer_can_be_recreated();\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}